(*Generated by Lem from elf.lem.*)
open Lem_list
open Lem_list_extra
open Lem_maybe
open Lem_num
open Lem_string

open Elf_header
open Elf_program_header_table
open Elf_section_header
open Elf_string_table
open Elf_symbol_table

open Bitstring
open Error

type linked_elf_file =
  { elf_header : elf32_elf_header
	 ; elf_section_header_table :  elf32_section_header_table option
	 ; elf_program_header_table : elf32_program_header_table
	 ; elf_string_table : string list
	 ; elf_dynamic_string_table : string list
	 ; elf_symbol_table : elf32_symbol_table list
	 }

type elf32
	= Linked of linked_elf_file
	| Executable
	
let is_linked elf =	
((match elf with
		| Linked _ -> true
		| _        -> false
  ))
  
let is_executable elf =	
((match elf with
		| Executable -> true
		| _          -> false
  ))
  
let string_of_elf32 elf320 =	
((match elf320 with
		| Executable ->
				List.fold_right (^) [
					"Executable ELF file"
				] ""
		| Linked link ->
			let shdr =				
((match link.elf_section_header_table with
					| None  -> "No section header table present"
					| Some hdr -> string_of_elf32_section_header_table hdr
				))
			in
			let symtabs =				
(List.fold_right (^) (List.map string_of_elf32_symbol_table link.elf_symbol_table) "")
			in
				List.fold_right (^) [
				  string_of_elf32_elf_header (fun x -> "Unsupported") (fun x -> "Unsupported") link.elf_header; "\n\n"
				; string_of_elf32_program_header_table (fun x -> "Unsupported") (fun x -> "Unsupported") link.elf_program_header_table
				; shdr
				; string_of_elf32_string_table link.elf_string_table
				; string_of_elf32_dynamic_string_table link.elf_dynamic_string_table
				; symtabs
				] "\t"
	))
  
let read_elf32 bs0 =	
(read_elf32_elf_header bs0 >>= (fun (elf_header0, bs1) ->
	let (size, entry_size) = (program_header_table_size_and_entry_size elf_header0) in
	read_elf32_program_header_table (size * entry_size) bs1 >>= (fun (program_header_table, bs2) ->
	(if elf32_elf_header_is_section_table_present elf_header0 then
		let (size, entry_size, offset) = (section_header_table_size_and_entry_size_and_offset elf_header0) in
	    read_elf32_section_header_table size entry_size offset bs0 >>= (fun (section_header_table, bs3) ->
	    return (Some section_header_table, bs3))
  	else
	    return (None, bs2)) >>= (fun (section_header_table_opt, bs3) ->
	let string_tables = (read_elf32_string_tables section_header_table_opt bs0) in
	((match section_header_table_opt with
	   | None -> return []
	   | Some section_header_table -> read_elf32_symbol_tables section_header_table bs0
	 )) >>= (fun symbol_table ->
  return (Linked (
    { elf_header = elf_header0
	   ; elf_section_header_table = section_header_table_opt
	   ; elf_program_header_table = program_header_table
	   ; elf_string_table = (List.nth (string_tables)( 1))
	   ; elf_dynamic_string_table = (List.nth (string_tables)( 0))
	   ; elf_symbol_table = symbol_table
	   })))))))
