chapter \<open>Generated by Lem from \<open>../../src/gen_lib/sail2_operators.lem\<close>.\<close>

theory "Sail2_operators" 

imports
  Main
  "LEM.Lem_pervasives_extra"
  "LEM.Lem_machine_word"
  "Sail2_values"

begin 

(*open import Pervasives_extra*)
(*open import Machine_word*)
(*open import Sail2_values*)

(*** Bit vector operations *)

(*val concat_bv : forall 'a 'b. Bitvector 'a, Bitvector 'b => 'a -> 'b -> list bitU*)
definition concat_bv  :: " 'a Bitvector_class \<Rightarrow> 'b Bitvector_class \<Rightarrow> 'a \<Rightarrow> 'b \<Rightarrow>(bitU)list "  where 
     " concat_bv dict_Sail2_values_Bitvector_a dict_Sail2_values_Bitvector_b l r = ( (
  (bits_of_method   dict_Sail2_values_Bitvector_a) l @(bits_of_method   dict_Sail2_values_Bitvector_b) r))"


(*val cons_bv : forall 'a. Bitvector 'a => bitU -> 'a -> list bitU*)
definition cons_bv  :: " 'a Bitvector_class \<Rightarrow> bitU \<Rightarrow> 'a \<Rightarrow>(bitU)list "  where 
     " cons_bv dict_Sail2_values_Bitvector_a b v = ( b # 
  (bits_of_method   dict_Sail2_values_Bitvector_a) v )"


(*val cast_unit_bv : bitU -> list bitU*)
definition cast_unit_bv  :: " bitU \<Rightarrow>(bitU)list "  where 
     " cast_unit_bv b = ( [b])"


(*val bv_of_bit : integer -> bitU -> list bitU*)
definition bv_of_bit  :: " int \<Rightarrow> bitU \<Rightarrow>(bitU)list "  where 
     " bv_of_bit len b = ( extz_bits len [b])"


definition most_significant  :: " 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> bitU "  where 
     " most_significant dict_Sail2_values_Bitvector_a v = ( (case  
  (bits_of_method   dict_Sail2_values_Bitvector_a) v of
    b # _ => b
  | _ => B0 (* Treat empty bitvector as all zeros *)
  ))"


definition get_max_representable_in  :: " bool \<Rightarrow> int \<Rightarrow> int "  where 
     " get_max_representable_in sign (n :: int) = (
  if (n =( 64 :: int)) then (case  sign of   True => max_64 | False => max_64u )
  else if (n=( 32 :: int)) then (case  sign of   True => max_32 | False => max_32u )
  else if (n=( 8 :: int)) then max_8
  else if (n=( 5 :: int)) then max_5
  else (case  sign of   True => (( 2 :: int))^ ((nat (abs ( n))) -( 1 :: nat))
                       | False => (( 2 :: int))^ (nat (abs ( n)))
       ))"


definition get_min_representable_in  :: " 'a \<Rightarrow> int \<Rightarrow> int "  where 
     " get_min_representable_in _ (n :: int) = (
  if n =( 64 :: int) then min_64
  else if n =( 32 :: int) then min_32
  else if n =( 8 :: int) then min_8
  else if n =( 5 :: int) then min_5
  else( 0 :: int) - ((( 2 :: int))^ (nat (abs ( n)))))"


(*val arith_op_bv_int : forall 'a 'b. Bitvector 'a =>
  (integer -> integer -> integer) -> bool -> 'a -> integer -> 'a*)
definition arith_op_bv_int  :: " 'a Bitvector_class \<Rightarrow>(int \<Rightarrow> int \<Rightarrow> int)\<Rightarrow> bool \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow> 'a "  where 
     " arith_op_bv_int dict_Sail2_values_Bitvector_a op1 sign l r = (
  (let r' = ((of_int_method   dict_Sail2_values_Bitvector_a) ((length_method   dict_Sail2_values_Bitvector_a) l) r) in (arith_op_bv_method   dict_Sail2_values_Bitvector_a) op1 sign l r'))"


(*val arith_op_int_bv : forall 'a 'b. Bitvector 'a =>
  (integer -> integer -> integer) -> bool -> integer -> 'a -> 'a*)
definition arith_op_int_bv  :: " 'a Bitvector_class \<Rightarrow>(int \<Rightarrow> int \<Rightarrow> int)\<Rightarrow> bool \<Rightarrow> int \<Rightarrow> 'a \<Rightarrow> 'a "  where 
     " arith_op_int_bv dict_Sail2_values_Bitvector_a op1 sign l r = (
  (let l' = ((of_int_method   dict_Sail2_values_Bitvector_a) ((length_method   dict_Sail2_values_Bitvector_a) r) l) in (arith_op_bv_method   dict_Sail2_values_Bitvector_a) op1 sign l' r))"


definition arith_op_bv_bool  :: " 'a Bitvector_class \<Rightarrow>(int \<Rightarrow> int \<Rightarrow> int)\<Rightarrow> bool \<Rightarrow> 'a \<Rightarrow> bool \<Rightarrow> 'a "  where 
     " arith_op_bv_bool dict_Sail2_values_Bitvector_a op1 sign l r = ( arith_op_bv_int 
  dict_Sail2_values_Bitvector_a op1 sign l (if r then( 1 :: int) else( 0 :: int)))"

definition arith_op_bv_bit  :: " 'a Bitvector_class \<Rightarrow>(int \<Rightarrow> int \<Rightarrow> int)\<Rightarrow> bool \<Rightarrow> 'a \<Rightarrow> bitU \<Rightarrow> 'a option "  where 
     " arith_op_bv_bit dict_Sail2_values_Bitvector_a op1 sign l r = ( map_option (arith_op_bv_bool 
  dict_Sail2_values_Bitvector_a op1 sign l) (bool_of_bitU r))"


(* TODO (or just omit and define it per spec if needed)
val arith_op_overflow_bv : forall 'a. Bitvector 'a =>
  (integer -> integer -> integer) -> bool -> integer -> 'a -> 'a -> (list bitU * bitU * bitU)
let arith_op_overflow_bv op sign size l r =
  let len = length l in
  let act_size = len * size in
  match (int_of_bv sign l, int_of_bv sign r, int_of_bv false l, int_of_bv false r) with
    | (Just l_sign, Just r_sign, Just l_unsign, Just r_unsign) ->
       let n = op l_sign r_sign in
       let n_unsign = op l_unsign r_unsign in
       let correct_size = of_int act_size n in
       let one_more_size_u = bits_of_int (act_size + 1) n_unsign in
       let overflow =
         if n <= get_max_representable_in sign len &&
              n >= get_min_representable_in sign len
         then B0 else B1 in
       let c_out = most_significant one_more_size_u in
       (correct_size,overflow,c_out)
    | (_, _, _, _) ->
       (repeat [BU] act_size, BU, BU)
  end

let add_overflow_bv = arith_op_overflow_bv integerAdd false 1
let adds_overflow_bv = arith_op_overflow_bv integerAdd true 1
let sub_overflow_bv = arith_op_overflow_bv integerMinus false 1
let subs_overflow_bv = arith_op_overflow_bv integerMinus true 1
let mult_overflow_bv = arith_op_overflow_bv integerMult false 2
let mults_overflow_bv = arith_op_overflow_bv integerMult true 2

val arith_op_overflow_bv_bit : forall 'a. Bitvector 'a =>
  (integer -> integer -> integer) -> bool -> integer -> 'a -> bitU -> (list bitU * bitU * bitU)
let arith_op_overflow_bv_bit op sign size l r_bit =
  let act_size = length l * size in
  match (int_of_bv sign l, int_of_bv false l, r_bit = BU) with
    | (Just l', Just l_u, false) ->
       let (n, nu, changed) = match r_bit with
         | B1 -> (op l' 1, op l_u 1, true)
         | B0 -> (l', l_u, false)
         | BU -> (* unreachable due to check above *)
            failwith arith_op_overflow_bv_bit applied to undefined bit
         end in
       let correct_size = of_int act_size n in
       let one_larger = bits_of_int (act_size + 1) nu in
       let overflow =
         if changed
         then
           if n <= get_max_representable_in sign act_size && n >= get_min_representable_in sign act_size
           then B0 else B1
         else B0 in
       (correct_size, overflow, most_significant one_larger)
    | (_, _, _) ->
       (repeat [BU] act_size, BU, BU)
  end

let add_overflow_bv_bit = arith_op_overflow_bv_bit integerAdd false 1
let adds_overflow_bv_bit = arith_op_overflow_bv_bit integerAdd true 1
let sub_overflow_bv_bit = arith_op_overflow_bv_bit integerMinus false 1
let subs_overflow_bv_bit = arith_op_overflow_bv_bit integerMinus true 1*)

datatype shift = LL_shift | RR_shift | RR_shift_arith | LL_rot | RR_rot

definition invert_shift  :: " shift \<Rightarrow> shift "  where 
     " invert_shift = ( \<lambda>x .  
  (case  x of
        LL_shift => RR_shift
    | RR_shift => LL_shift
    | RR_shift_arith => LL_shift
    | LL_rot => RR_rot
    | RR_rot => LL_rot
  ) )"


(*val shift_op_bv : forall 'a. Bitvector 'a => shift -> 'a -> integer -> list bitU*)
definition shift_op_bv  :: " 'a Bitvector_class \<Rightarrow> shift \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow>(bitU)list "  where 
     " shift_op_bv dict_Sail2_values_Bitvector_a op1 v n = (
  (let v = ((bits_of_method   dict_Sail2_values_Bitvector_a) v) in
  if n =( 0 :: int) then v else
  (let (op1, n) = (if n >( 0 :: int) then (op1, n) else (invert_shift op1, - n)) in
  (case  op1 of
    LL_shift =>
     subrange_list True v n (int (List.length v) -( 1 :: int)) @ repeat [B0] n
  | RR_shift =>
     repeat [B0] n @ subrange_list True v(( 0 :: int)) ((int (List.length v) - n) -( 1 :: int))
  | RR_shift_arith =>
     repeat [most_significant 
  (instance_Sail2_values_Bitvector_list_dict
     instance_Sail2_values_BitU_Sail2_values_bitU_dict) v] n @ subrange_list True v(( 0 :: int)) ((int (List.length v) - n) -( 1 :: int))
  | LL_rot =>
     subrange_list True v n (int (List.length v) -( 1 :: int)) @ subrange_list True v(( 0 :: int)) (n -( 1 :: int))
  | RR_rot =>
     subrange_list False v(( 0 :: int)) (n -( 1 :: int)) @ subrange_list False v n (int (List.length v) -( 1 :: int))
  ))))"


definition shiftl_bv  :: " 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow>(bitU)list "  where 
     " shiftl_bv dict_Sail2_values_Bitvector_a = ( shift_op_bv 
  dict_Sail2_values_Bitvector_a LL_shift )"
 (*<<*)
definition shiftr_bv  :: " 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow>(bitU)list "  where 
     " shiftr_bv dict_Sail2_values_Bitvector_a = ( shift_op_bv 
  dict_Sail2_values_Bitvector_a RR_shift )"
 (*>>*)
definition arith_shiftr_bv  :: " 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow>(bitU)list "  where 
     " arith_shiftr_bv dict_Sail2_values_Bitvector_a = ( shift_op_bv 
  dict_Sail2_values_Bitvector_a RR_shift_arith )"

definition rotl_bv  :: " 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow>(bitU)list "  where 
     " rotl_bv dict_Sail2_values_Bitvector_a = ( shift_op_bv 
  dict_Sail2_values_Bitvector_a LL_rot )"
 (*<<<*)
definition rotr_bv  :: " 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow>(bitU)list "  where 
     " rotr_bv dict_Sail2_values_Bitvector_a = ( shift_op_bv 
  dict_Sail2_values_Bitvector_a LL_rot )"
 (*>>>*)

definition shiftl_mword  :: "('a::len)Word.word \<Rightarrow> int \<Rightarrow>('a::len)Word.word "  where 
     " shiftl_mword w n = ( w << (nat_of_int n))"

definition shiftr_mword  :: "('a::len)Word.word \<Rightarrow> int \<Rightarrow>('a::len)Word.word "  where 
     " shiftr_mword w n = ( w >> (nat_of_int n))"

definition arith_shiftr_mword  :: "('a::len)Word.word \<Rightarrow> int \<Rightarrow>('a::len)Word.word "  where 
     " arith_shiftr_mword w n = ( w >>> (nat_of_int n))"

definition rotl_mword  :: "('a::len)Word.word \<Rightarrow> int \<Rightarrow>('a::len)Word.word "  where 
     " rotl_mword w n = ( Word.word_rotl (nat_of_int n) w )"

definition rotr_mword  :: "('a::len)Word.word \<Rightarrow> int \<Rightarrow>('a::len)Word.word "  where 
     " rotr_mword w n = ( Word.word_rotr (nat_of_int n) w )"


fun  arith_op_no0  :: "(int \<Rightarrow> int \<Rightarrow> int)\<Rightarrow> int \<Rightarrow> int \<Rightarrow>(int)option "  where 
     " arith_op_no0 (op1 :: int \<Rightarrow> int \<Rightarrow> int) l r = (
  if r =( 0 :: int)
  then None
  else Some (op1 l r))"


(*val arith_op_bv_no0 : forall 'a 'b. Bitvector 'a, Bitvector 'b =>
  (integer -> integer -> integer) -> bool -> integer -> 'a -> 'a -> maybe 'b*)
definition arith_op_bv_no0  :: " 'a Bitvector_class \<Rightarrow> 'b Bitvector_class \<Rightarrow>(int \<Rightarrow> int \<Rightarrow> int)\<Rightarrow> bool \<Rightarrow> int \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> 'b option "  where 
     " arith_op_bv_no0 dict_Sail2_values_Bitvector_a dict_Sail2_values_Bitvector_b op1 sign size1 l r = (
  Option.bind (int_of_bv 
  dict_Sail2_values_Bitvector_a sign l) (\<lambda> l' . 
  Option.bind (int_of_bv 
  dict_Sail2_values_Bitvector_a sign r) (\<lambda> r' . 
  if r' =( 0 :: int) then None else Some (
  (of_int_method   dict_Sail2_values_Bitvector_b) ((length_method   dict_Sail2_values_Bitvector_a) l * size1) (op1 l' r')))))"


definition mod_bv  :: " 'a Bitvector_class \<Rightarrow> 'b Bitvector_class \<Rightarrow> 'b \<Rightarrow> 'b \<Rightarrow> 'a option "  where 
     " mod_bv dict_Sail2_values_Bitvector_a dict_Sail2_values_Bitvector_b = ( arith_op_bv_no0 
  dict_Sail2_values_Bitvector_b dict_Sail2_values_Bitvector_a hardware_mod False(( 1 :: int)))"

definition quot_bv  :: " 'a Bitvector_class \<Rightarrow> 'b Bitvector_class \<Rightarrow> 'b \<Rightarrow> 'b \<Rightarrow> 'a option "  where 
     " quot_bv dict_Sail2_values_Bitvector_a dict_Sail2_values_Bitvector_b = ( arith_op_bv_no0 
  dict_Sail2_values_Bitvector_b dict_Sail2_values_Bitvector_a hardware_quot False(( 1 :: int)))"

definition quots_bv  :: " 'a Bitvector_class \<Rightarrow> 'b Bitvector_class \<Rightarrow> 'b \<Rightarrow> 'b \<Rightarrow> 'a option "  where 
     " quots_bv dict_Sail2_values_Bitvector_a dict_Sail2_values_Bitvector_b = ( arith_op_bv_no0 
  dict_Sail2_values_Bitvector_b dict_Sail2_values_Bitvector_a hardware_quot True(( 1 :: int)))"


definition mod_mword  :: "('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word "  where 
     " mod_mword = ( (mod))"

definition quot_mword  :: "('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word "  where 
     " quot_mword = ( (div))"

definition quots_mword  :: "('a::len)Word.word \<Rightarrow>('a::len)Word.word \<Rightarrow>('a::len)Word.word "  where 
     " quots_mword = ( Lem_machine_word.signedDivide )"


definition arith_op_bv_int_no0  :: " 'a Bitvector_class \<Rightarrow> 'b Bitvector_class \<Rightarrow>(int \<Rightarrow> int \<Rightarrow> int)\<Rightarrow> bool \<Rightarrow> int \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow> 'b option "  where 
     " arith_op_bv_int_no0 dict_Sail2_values_Bitvector_a dict_Sail2_values_Bitvector_b op1 sign size1 l r = (
  arith_op_bv_no0 dict_Sail2_values_Bitvector_a dict_Sail2_values_Bitvector_b op1 sign size1 l ((of_int_method   dict_Sail2_values_Bitvector_a) ((length_method   dict_Sail2_values_Bitvector_a) l) r))"


definition quot_bv_int  :: " 'a Bitvector_class \<Rightarrow> 'b Bitvector_class \<Rightarrow> 'b \<Rightarrow> int \<Rightarrow> 'a option "  where 
     " quot_bv_int dict_Sail2_values_Bitvector_a dict_Sail2_values_Bitvector_b = ( arith_op_bv_int_no0 
  dict_Sail2_values_Bitvector_b dict_Sail2_values_Bitvector_a hardware_quot False(( 1 :: int)))"

definition mod_bv_int  :: " 'a Bitvector_class \<Rightarrow> 'b Bitvector_class \<Rightarrow> 'b \<Rightarrow> int \<Rightarrow> 'a option "  where 
     " mod_bv_int dict_Sail2_values_Bitvector_a dict_Sail2_values_Bitvector_b = ( arith_op_bv_int_no0 
  dict_Sail2_values_Bitvector_b dict_Sail2_values_Bitvector_a hardware_mod False(( 1 :: int)))"


definition mod_mword_int  :: "('a::len)Word.word \<Rightarrow> int \<Rightarrow>('a::len)Word.word "  where 
     " mod_mword_int l r = ( l mod (Word.word_of_int r))"

definition quot_mword_int  :: "('a::len)Word.word \<Rightarrow> int \<Rightarrow>('a::len)Word.word "  where 
     " quot_mword_int l r = ( l div (Word.word_of_int r))"

definition quots_mword_int  :: "('a::len)Word.word \<Rightarrow> int \<Rightarrow>('a::len)Word.word "  where 
     " quots_mword_int l r = ( Lem_machine_word.signedDivide l (Word.word_of_int r))"


definition replicate_bits_bv  :: " 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow>(bitU)list "  where 
     " replicate_bits_bv dict_Sail2_values_Bitvector_a v count1 = ( repeat (
  (bits_of_method   dict_Sail2_values_Bitvector_a) v) count1 )"

definition duplicate_bit_bv  :: " 'a BitU_class \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow>(bitU)list "  where 
     " duplicate_bit_bv dict_Sail2_values_BitU_a bit len = ( replicate_bits_bv 
  (instance_Sail2_values_Bitvector_list_dict dict_Sail2_values_BitU_a) [bit] len )"


(*val eq_bv : forall 'a. Bitvector 'a => 'a -> 'a -> bool*)
definition eq_bv  :: " 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> bool "  where 
     " eq_bv dict_Sail2_values_Bitvector_a l r = ( (
  (bits_of_method   dict_Sail2_values_Bitvector_a) l =(bits_of_method   dict_Sail2_values_Bitvector_a) r))"


(*val neq_bv : forall 'a. Bitvector 'a => 'a -> 'a -> bool*)
definition neq_bv  :: " 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> bool "  where 
     " neq_bv dict_Sail2_values_Bitvector_a l r = ( \<not> (eq_bv 
  dict_Sail2_values_Bitvector_a l r))"


(*val get_slice_int_bv : forall 'a. Bitvector 'a => integer -> integer -> integer -> 'a*)
definition get_slice_int_bv  :: " 'a Bitvector_class \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'a "  where 
     " get_slice_int_bv dict_Sail2_values_Bitvector_a len n lo = (
  (let hi = ((lo + len) -( 1 :: int)) in
  (let bs = (bools_of_int (hi +( 1 :: int)) n) in 
  (of_bools_method   dict_Sail2_values_Bitvector_a) (subrange_list False bs hi lo))))"


(*val set_slice_int_bv : forall 'a. Bitvector 'a => integer -> integer -> integer -> 'a -> integer*)
definition set_slice_int_bv  :: " 'a Bitvector_class \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'a \<Rightarrow> int "  where 
     " set_slice_int_bv dict_Sail2_values_Bitvector_a len n lo v = (
  (let hi = ((lo + len) -( 1 :: int)) in
  (let bs = (bits_of_int (hi +( 1 :: int)) n) in
  maybe_failwith (signed_of_bits (update_subrange_list False bs hi lo (
  (bits_of_method   dict_Sail2_values_Bitvector_a) v))))))"

end
