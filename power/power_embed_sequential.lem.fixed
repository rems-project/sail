(*Generated by Sail from generated/power.sail.*)
open import Pervasives_extra
open import Sail_impl_base
open import State
open import Sail_values
open import Power_embed_types
open import Power_extras_embed_sequential
let DEC_TO_BCD (Vector [p;q;r;s;t;u;v;w;x;y] _ _) =
  let a = ((~s) &. (v &. w)) |. ((t &. (v &. (w &. s))) |. (v &. (w &. (~x)))) in
  let b = (p &. (s &. (x &. (~t)))) |. ((p &. (~w)) |. (p &. (~v))) in
  let c = (q &. (s &. (x &. (~t)))) |. ((q &. (~w)) |. (q &. (~v))) in
  let d = r in
  let e = (v &. ((~w) &. x)) |. ((s &. (v &. (w &. x))) |. ((~t) &. (v &. (x &. w)))) in
  let f = (p &. (t &. (v &. (w &. (x &. (~s)))))) |. ((s &. ((~x) &. v)) |. (s &. (~v))) in
  let g = (q &. (t &. (w &. (v &. (x &. (~s)))))) |. ((t &. ((~x) &. v)) |. (t &. (~v))) in
  let h = u in
  let i = (t &. (v &. (w &. x))) |. ((s &. (v &. (w &. x))) |. (v &. ((~w) &. (~x)))) in
  let j =
    (p &. ((~s) &. ((~t) &. (w &. v)))) |.
      ((s &. (v &. ((~w) &. x))) |. ((p &. (w &. ((~x) &. v))) |. (w &. (~v)))) in
  let k =
    (q &. ((~s) &. ((~t) &. (v &. w)))) |.
      ((t &. (v &. ((~w) &. x))) |. ((q &. (v &. (w &. (~x)))) |. (x &. (~v)))) in
  let m = y in
  Vector [a;b;c;d;e;f;g;h;i;j;k;m] 0 true

let BCD_TO_DEC (Vector [a;b;c;d;e;f;g;h;i;j;k;m] _ _) =
  let p = (f &. (a &. (i &. (~e)))) |. ((j &. (a &. (~i))) |. (b &. (~a))) in
  let q = (g &. (a &. (i &. (~e)))) |. ((k &. (a &. (~i))) |. (c &. (~a))) in
  let r = d in
  let s =
    (j &. ((~a) &. (e &. (~i)))) |. ((f &. ((~i) &. (~e))) |. ((f &. ((~a) &. (~e))) |. (e &. i))) in
  let t =
    (k &. ((~a) &. (e &. (~i)))) |. ((g &. ((~i) &. (~e))) |. ((g &. ((~a) &. (~e))) |. (a &. i))) in
  let u = h in
  let v = a |. (e |. i) in
  let w = ((~e) &. (j &. (~i))) |. ((e &. i) |. a) in
  let x = ((~a) &. (k &. (~i))) |. ((a &. i) |. e) in
  let y = m in
  Vector [p;q;r;s;t;u;v;w;x;y] 0 true

let carry_out (_, carry) = carry

let real_addr x = x

let mark_as_not_likely_to_be_needed_again_anytime_soon x = ()

let EXTS_EXPLICIT (v, m) = (duplicate (access v (0:ii), m - (length (reset_vector_start v)))) ^^ v

let MASK (start, stop) =
  let mask_temp = to_vec_inc ((64:ii),(0:ii)) in
  if bitU_to_bool (gt (start, stop))
  then
    let mask_temp = update mask_temp start (63:ii) (duplicate (B1, (64:ii) - start)) in
    update mask_temp (0:ii) stop (duplicate (B1, stop + (1:ii)))
  else update mask_temp start stop (duplicate (B1, (stop - start) + (1:ii)))

let ROTL (v, n) = (slice v n (63:ii)) ^^ (slice v (0:ii) (n - (1:ii)))

let DOUBLE word =
  let temp = to_vec_inc ((64:ii),(0:ii)) in
  if bitU_to_bool
       ((gt_vec_range (slice word (1:ii) (8:ii), (0:ii))) &.
          (lt_vec_range (slice word (1:ii) (8:ii), (255:ii))))
  then
    let temp = update temp (0:ii) (1:ii) (slice word (0:ii) (1:ii)) in
    let temp = update_pos temp (2:ii) (~(access word (1:ii))) in
    let temp = update_pos temp (3:ii) (~(access word (1:ii))) in
    let temp = update_pos temp (4:ii) (~(access word (1:ii))) in
    update
      temp (5:ii) (63:ii)
      (set_vector_start 5
        ((slice word (2:ii) (31:ii)) ^^
         (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                  B0;B0;B0;B0;B0;B0;B0;B0] 0 true)))
  else
    if bitU_to_bool
         ((eq_vec_range (slice word (1:ii) (8:ii), (0:ii))) &.
            (neq_vec_range (slice word (9:ii) (31:ii), (0:ii))))
    then
      let sign = access word (0:ii) in
      let exp = (0:ii) - (126:ii) in
      let frac =
        (Vector [B0] 0 true) ^^
        ((slice word (9:ii) (31:ii)) ^^
         (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                  B0;B0;B0;B0;B0;B0;B0;B0] 0 true)) in
      let (exp, frac) =
        (foreach_inc ((0:ii),(52:ii),(1:ii)) (exp,frac)
          (fun i (exp,frac) ->
           let (frac, exp) =
             if bitU_to_bool
                  (eq (match (access frac (0:ii)) with | B0 -> (0:ii) | B1 -> (1:ii) end, (0:ii)))
             then
               let frac =
                 update frac (0:ii) (52:ii) ((slice frac (1:ii) (52:ii)) ^^ (Vector [B0] 0 true)) in
               let exp = exp - (1:ii) in
               (frac,exp)
             else (frac,exp) in
           (exp,frac))) in
      let temp = update_pos temp (0:ii) sign in
      let temp =
        update
          temp (1:ii) (11:ii)
          (add_VIV (reset_vector_start (to_vec_inc ((11:ii),exp))) (1023:ii)) in
      update temp (12:ii) (63:ii) (set_vector_start 12 (slice frac (1:ii) (52:ii)))
    else
      let temp = update temp (0:ii) (1:ii) (slice word (0:ii) (1:ii)) in
      let temp = update_pos temp (2:ii) (access word (1:ii)) in
      let temp = update_pos temp (3:ii) (access word (1:ii)) in
      let temp = update_pos temp (4:ii) (access word (1:ii)) in
      update
        temp (5:ii) (63:ii)
        (set_vector_start 5
          ((slice word (2:ii) (31:ii)) ^^
           (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                    B0;B0;B0;B0;B0;B0;B0;B0] 0 true)))

let SINGLE frs =
  let word = to_vec_inc ((32:ii),(0:ii)) in
  if bitU_to_bool
       ((gt_vec_range (slice frs (1:ii) (11:ii), (896:ii))) |.
          (eq_vec_range (slice frs (1:ii) (63:ii), (0:ii))))
  then
    let word = update word (0:ii) (1:ii) (slice frs (0:ii) (1:ii)) in
    update word (2:ii) (31:ii) (set_vector_start 2 (slice frs (5:ii) (34:ii)))
  else
    if bitU_to_bool
         ((lteq_range_vec ((874:ii), slice frs (1:ii) (11:ii))) &.
            (lteq_vec_range (slice frs (1:ii) (11:ii), (896:ii))))
    then
      let sign = access frs (0:ii) in
      let exp =
        set_vector_start 0 (minus_VIV (reset_vector_start (slice frs (1:ii) (11:ii))) (1023:ii)) in
      let frac = (Vector [B1] 0 true) ^^ (slice frs (12:ii) (63:ii)) in
      let (exp, frac) =
        (foreach_inc ((0:ii),(53:ii),(1:ii)) (exp,frac)
          (fun i (exp,frac) ->
           let (frac, exp) =
             if bitU_to_bool (lt_vec_range (exp, (0:ii) - (126:ii)))
             then
               let frac =
                 update frac (0:ii) (52:ii) ((Vector [B0] 0 true) ^^ (slice frac (0:ii) (51:ii))) in
               let exp = set_vector_start 0 (add_VIV (reset_vector_start exp) (1:ii)) in
               (frac,exp)
             else (frac,exp) in
           (exp,frac))) in
      word
    else to_vec_inc_undef (32:ii)

let Chop (x, y) = slice x (0:ii) y

let byte_reverse (m', input) =
  let output = to_vec_inc (length input,(0:ii)) in
  let j = length (reset_vector_start input) in
  let (j, output) =
    (foreach_inc ((0:ii),length (reset_vector_start input),(8:ii)) (j,output)
      (fun i (j,output) ->
       let output = update output i (i + (7:ii)) (slice input (j - (7:ii)) j) in
       let j = j - (8:ii) in
       (j,output))) in
  output

let rec reverse_endianness value =
  let width = length (reset_vector_start value) in
  let half = quot width (2:ii) in
  if bitU_to_bool (eq_range (width, (8:ii)))
  then value
  else
    (reverse_endianness
       (reset_vector_start (set_vector_start 0 (slice value half (width - (1:ii)))))) ^^
    (reverse_endianness (reset_vector_start (slice value (0:ii) (half - (1:ii)))))

let zero_or_undef x =
  let out = to_vec_inc (length x,(0:ii)) in
  (foreach_inc ((0:ii),(length (reset_vector_start x)) - (1:ii),(1:ii)) out
    (fun i out -> update_pos out i (if bitU_to_bool (access x i) then BU else B0)))

let GPRs =
  Vector ["GPR0";"GPR1";"GPR2";"GPR3";"GPR4";"GPR5";"GPR6";"GPR7";"GPR8";"GPR9";"GPR10";"GPR11";"GPR12";"GPR13";"GPR14";"GPR15";"GPR16";"GPR17";"GPR18";"GPR19";"GPR20";
          "GPR21";"GPR22";"GPR23";"GPR24";"GPR25";"GPR26";"GPR27";"GPR28";"GPR29";"GPR30";"GPR31"] 0 true

let SPRs =
  make_indexed_vector
    [(1,"XER");(8,"LR");(9,"CTR");(259,"SPRG3");(260,"SPRG4");(261,"SPRG5");
     (262,"SPRG6");(263,"SPRG7")]
    "" 0 1024 true

let DCRs = make_indexed_vector [(0,"DCR0");(1,"DCR1")] "" 0 1024 true

let length_spr i =
  match toNatural i with
  | (1:nn) -> (64:ii)
  | (8:nn) -> (64:ii)
  | (9:nn) -> (64:ii)
  | (259:nn) -> (64:ii)
  | (260:nn) -> (64:ii)
  | (261:nn) -> (64:ii)
  | (262:nn) -> (64:ii)
  | (263:nn) -> (64:ii)
  end

let DCR = make_indexed_vector [(0,DCR0);(1,DCR1)] (UndefinedRegister 64) 0 1024 true

let Clamp (k', x, y, z) =
  let result = (0:ii) in
  (if bitU_to_bool (lt (x, y))
   then
     let result = y in
     write_reg_bitfield VSCR "SAT" B1 >>
     return result
   else
     if bitU_to_bool (gt (x, z))
     then
       let result = z in
       write_reg_bitfield VSCR "SAT" B1 >>
       return result
     else return x) >>= fun result ->
  return (to_vec_inc (k',result))

let MEMw (ea, size, value) =
  read_reg bigendianmode >>= fun w__0 ->
  if bitU_to_bool (most_significant w__0)
  then
    MEMw'
      (reset_vector_start ea,
       size,
       reset_vector_start (reverse_endianness (reset_vector_start value)))
  else MEMw' (reset_vector_start ea,size,reset_vector_start value)

let MEMr (ea, size) =
  read_reg bigendianmode >>= fun w__0 ->
  if bitU_to_bool (most_significant w__0)
  then
    MEMr' (reset_vector_start ea,size) >>= fun w__1 ->
    return (reverse_endianness (reset_vector_start w__1))
  else MEMr' (reset_vector_start ea,size)

let MEMr_reserve (ea, size) =
  read_reg bigendianmode >>= fun w__0 ->
  if bitU_to_bool (most_significant w__0)
  then
    MEMr_reserve' (reset_vector_start ea,size) >>= fun w__1 ->
    return (reverse_endianness (reset_vector_start w__1))
  else MEMr_reserve' (reset_vector_start ea,size)

let MEMw_conditional (ea, size, value) =
  read_reg bigendianmode >>= fun w__0 ->
  if bitU_to_bool (most_significant w__0)
  then
    MEMw_conditional'
      (reset_vector_start ea,
       size,
       reset_vector_start (reverse_endianness (reset_vector_start value)))
  else MEMw_conditional' (reset_vector_start ea,size,reset_vector_start value)

let set_SO_OV overflow =
  write_reg_bitfield XER "OV" overflow >>
  read_reg_bitfield XER "SO" >>= fun w__0 ->
  write_reg_bitfield XER "SO" (w__0 |. overflow)

let supported_instructions instr =
  match instr with
  | Sync ((Vector [B1;B0] _ _)) -> Nothing
  | Sync ((Vector [B1;B1] _ _)) -> Nothing
  | _ -> Just instr
  end

let CIA_fp = RFull "CIA"

let NIA_fp = RFull "NIA"

let mode64bit_fp = RFull "mode64bit"

let bigendianmode_fp = RFull "bigendianmode"

let set_overflow_cr0 (target_register, new_xer_so) =
  let m = (0:ii) in
  let c = to_vec_inc ((3:ii),(0:ii)) in
  let zero = to_vec_inc ((64:ii),(0:ii)) in
  read_reg mode64bit >>= fun w__0 ->
  let m = if bitU_to_bool (most_significant w__0) then (0:ii) else (32:ii) in
  let c =
    if bitU_to_bool (lt_vec_signed (slice target_register m (63:ii), slice zero m (63:ii)))
    then Vector [B1;B0;B0] 0 true
    else
      if bitU_to_bool (gt_vec_signed (slice target_register m (63:ii), slice zero m (63:ii)))
      then Vector [B0;B1;B0] 0 true
      else Vector [B0;B0;B1] 0 true in
  write_reg_field CR "CR0" (set_vector_start 32 (c ^^ (Vector [new_xer_so] 0 true)))

let SPR =
  make_indexed_vector
    [(1,XER);(8,LR);(9,CTR);(259,SPRG3);(260,SPRG4);(261,SPRG5);
     (262,SPRG6);(263,SPRG7)]
    (UndefinedRegister 64) 0 1024 true

let FPRp =
  make_indexed_vector
    [(0,RegisterPair FPR0 FPR1);(2,RegisterPair FPR2 FPR3);(4,RegisterPair FPR4 FPR5);(6,RegisterPair FPR6 FPR7);(8,RegisterPair FPR8 FPR9);(10,RegisterPair FPR10 FPR11);
     (12,RegisterPair FPR12 FPR13);(14,RegisterPair FPR14 FPR15);(16,RegisterPair FPR16 FPR17);(18,RegisterPair FPR18 FPR19);(20,RegisterPair FPR20 FPR21);(22,RegisterPair FPR22 FPR23);
     (24,RegisterPair FPR24 FPR25);(26,RegisterPair FPR26 FPR27);(28,RegisterPair FPR28 FPR29);(30,RegisterPair FPR30 FPR31)]
    (UndefinedRegister 128) 0 32 true

let illegal_instructions_pred instr =
  match instr with
  | Bcctr (BO,BI,BH,LK) -> ~(access BO (2:ii))
  | Lbzu (RT,RA,D) -> (eq_vec_range (RA, (0:ii))) |. (eq_vec (RA, RT))
  | Lbzux (RT,RA,_) -> (eq_vec_range (RA, (0:ii))) |. (eq_vec (RA, RT))
  | Lhzu (RT,RA,D) -> (eq_vec_range (RA, (0:ii))) |. (eq_vec (RA, RT))
  | Lhzux (RT,RA,RB) -> (eq_vec_range (RA, (0:ii))) |. (eq_vec (RA, RT))
  | Lhau (RT,RA,D) -> (eq_vec_range (RA, (0:ii))) |. (eq_vec (RA, RT))
  | Lhaux (RT,RA,RB) -> (eq_vec_range (RA, (0:ii))) |. (eq_vec (RA, RT))
  | Lwzu (RA,RT,D) -> (eq_vec_range (RA, (0:ii))) |. (eq_vec (RA, RT))
  | Lwzux (RT,RA,RB) -> (eq_vec_range (RA, (0:ii))) |. (eq_vec (RA, RT))
  | Lwaux (RA,RT,RB) -> (eq_vec_range (RA, (0:ii))) |. (eq_vec (RA, RT))
  | Ldu (RT,RA,DS) -> (eq_vec_range (RA, (0:ii))) |. (eq_vec (RA, RT))
  | Ldux (RT,RA,RB) -> (eq_vec_range (RA, (0:ii))) |. (eq_vec (RA, RT))
  | Stbu (RS,RA,D) -> eq_vec_range (RA, (0:ii))
  | Stbux (RS,RA,RB) -> eq_vec_range (RA, (0:ii))
  | Sthu (RS,RA,RB) -> eq_vec_range (RA, (0:ii))
  | Sthux (RS,RA,RB) -> eq_vec_range (RA, (0:ii))
  | Stwu (RS,RA,D) -> eq_vec_range (RA, (0:ii))
  | Stwux (RS,RA,RB) -> eq_vec_range (RA, (0:ii))
  | Stdu (RS,RA,DS) -> eq_vec_range (RA, (0:ii))
  | Stdux (RS,RA,RB) -> eq_vec_range (RA, (0:ii))
  | Lmw (RT,RA,D) ->
     (eq_vec_range (RA, (0:ii))) |. ((lteq_vec (RT, RA)) &. (lteq_vec_range (RA, (31:ii))))
  | Lswi (RT,RA,NB) ->
     let n =
       if bitU_to_bool (~(eq_vec_range (NB, (0:ii))))
       then unsigned (reset_vector_start NB)
       else (32:ii) in
     let ceil =
       if bitU_to_bool (eq_range (modulo n (4:ii), (0:ii)))
       then quot n (4:ii)
       else (quot n (4:ii)) + (1:ii) in
     (lteq_vec (RT, RA)) &.
       (lteq_vec
          (RA,
          minus_VIV
            (reset_vector_start (set_vector_start 0 (add_VIV (reset_vector_start RT) ceil)))
            (1:ii)))
  | Lq (RTp,RA,DQ,Pt) ->
     (eq_vec_range (minus_VIV (reset_vector_start RTp) (2:ii), (1:ii))) |. (eq_vec (RTp, RA))
  | Stq (RSp,RA,RS) -> eq_vec_range (minus_VIV (reset_vector_start RSp) (2:ii), (1:ii))
  | Mtspr (RS,spr) ->
     ~((eq_vec_range (spr, (1:ii))) |.
         ((eq_vec_range (spr, (8:ii))) |.
            ((eq_vec_range (spr, (9:ii))) |.
               ((eq_vec_range (spr, (256:ii))) |.
                  ((eq_vec_range (spr, (512:ii))) |.
                     ((eq_vec_range (spr, (896:ii))) |. (eq_vec_range (spr, (898:ii)))))))))
  | _ -> B0
  end

let GPR =
  Vector [GPR0;GPR1;GPR2;GPR3;GPR4;GPR5;GPR6;GPR7;GPR8;GPR9;GPR10;GPR11;GPR12;GPR13;GPR14;GPR15;GPR16;GPR17;GPR18;GPR19;GPR20;
          GPR21;GPR22;GPR23;GPR24;GPR25;GPR26;GPR27;GPR28;GPR29;GPR30;GPR31] 0 true

let FPR =
  Vector [FPR0;FPR1;FPR2;FPR3;FPR4;FPR5;FPR6;FPR7;FPR8;FPR9;FPR10;FPR11;FPR12;FPR13;FPR14;FPR15;FPR16;FPR17;FPR18;FPR19;FPR20;
          FPR21;FPR22;FPR23;FPR24;FPR25;FPR26;FPR27;FPR28;FPR29;FPR30;FPR31] 0 true

let VR =
  Vector [VR0;VR1;VR2;VR3;VR4;VR5;VR6;VR7;VR8;VR9;VR10;VR11;VR12;VR13;VR14;VR15;VR16;VR17;VR18;VR19;VR20;
          VR21;VR22;VR23;VR24;VR25;VR26;VR27;VR28;VR29;VR30;VR31] 0 true

let decode = function
  | ((Vector [B0;B1;B0;B0;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;AA;LK] _ _) as instr) ->
     let LI = slice_raw instr (6:ii) (29:ii) in
     Just (B (reset_vector_start LI,AA,LK))
  | ((Vector [B0;B1;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;AA;LK] _ _) as instr) ->
     let BO = slice_raw instr (6:ii) (10:ii) in
     let BI = slice_raw instr (11:ii) (15:ii) in
     let BD = slice_raw instr (16:ii) (29:ii) in
     Just (Bc (reset_vector_start BO,reset_vector_start BI,reset_vector_start BD,AA,LK))
  | ((Vector [B0;B1;B0;B0;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;LK] _ _) as instr) ->
     let BO = slice_raw instr (6:ii) (10:ii) in
     let BI = slice_raw instr (11:ii) (15:ii) in
     let BH = slice_raw instr (19:ii) (20:ii) in
     Just (Bclr (reset_vector_start BO,reset_vector_start BI,reset_vector_start BH,LK))
  | ((Vector [B0;B1;B0;B0;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B0;B0;B0;B0;B1;B0;B0;B0;B0;LK] _ _) as instr) ->
     let BO = slice_raw instr (6:ii) (10:ii) in
     let BI = slice_raw instr (11:ii) (15:ii) in
     let BH = slice_raw instr (19:ii) (20:ii) in
     Just (Bcctr (reset_vector_start BO,reset_vector_start BI,reset_vector_start BH,LK))
  | ((Vector [B0;B1;B0;B0;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B0;B0;B0;B0;B0;B0;B0;B1;_] _ _) as instr) ->
     let BT = slice_raw instr (6:ii) (10:ii) in
     let BA = slice_raw instr (11:ii) (15:ii) in
     let BB = slice_raw instr (16:ii) (20:ii) in
     Just (Crand (reset_vector_start BT,reset_vector_start BA,reset_vector_start BB))
  | ((Vector [B0;B1;B0;B0;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;B1;B1;B0;B0;B0;B0;B1;_] _ _) as instr) ->
     let BT = slice_raw instr (6:ii) (10:ii) in
     let BA = slice_raw instr (11:ii) (15:ii) in
     let BB = slice_raw instr (16:ii) (20:ii) in
     Just (Crnand (reset_vector_start BT,reset_vector_start BA,reset_vector_start BB))
  | ((Vector [B0;B1;B0;B0;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B1;B1;B0;B0;B0;B0;B0;B1;_] _ _) as instr) ->
     let BT = slice_raw instr (6:ii) (10:ii) in
     let BA = slice_raw instr (11:ii) (15:ii) in
     let BB = slice_raw instr (16:ii) (20:ii) in
     Just (Cror (reset_vector_start BT,reset_vector_start BA,reset_vector_start BB))
  | ((Vector [B0;B1;B0;B0;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;_] _ _) as instr) ->
     let BT = slice_raw instr (6:ii) (10:ii) in
     let BA = slice_raw instr (11:ii) (15:ii) in
     let BB = slice_raw instr (16:ii) (20:ii) in
     Just (Crxor (reset_vector_start BT,reset_vector_start BA,reset_vector_start BB))
  | ((Vector [B0;B1;B0;B0;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B1;B0;B0;B0;B0;B1;_] _ _) as instr) ->
     let BT = slice_raw instr (6:ii) (10:ii) in
     let BA = slice_raw instr (11:ii) (15:ii) in
     let BB = slice_raw instr (16:ii) (20:ii) in
     Just (Crnor (reset_vector_start BT,reset_vector_start BA,reset_vector_start BB))
  | ((Vector [B0;B1;B0;B0;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B0;B0;B1;B0;B0;B0;B0;B1;_] _ _) as instr) ->
     let BT = slice_raw instr (6:ii) (10:ii) in
     let BA = slice_raw instr (11:ii) (15:ii) in
     let BB = slice_raw instr (16:ii) (20:ii) in
     Just (Creqv (reset_vector_start BT,reset_vector_start BA,reset_vector_start BB))
  | ((Vector [B0;B1;B0;B0;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;_] _ _) as instr) ->
     let BT = slice_raw instr (6:ii) (10:ii) in
     let BA = slice_raw instr (11:ii) (15:ii) in
     let BB = slice_raw instr (16:ii) (20:ii) in
     Just (Crandc (reset_vector_start BT,reset_vector_start BA,reset_vector_start BB))
  | ((Vector [B0;B1;B0;B0;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;_] _ _) as instr) ->
     let BT = slice_raw instr (6:ii) (10:ii) in
     let BA = slice_raw instr (11:ii) (15:ii) in
     let BB = slice_raw instr (16:ii) (20:ii) in
     Just (Crorc (reset_vector_start BT,reset_vector_start BA,reset_vector_start BB))
  | ((Vector [B0;B1;B0;B0;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;_] _ _) as instr) ->
     let BF = slice_raw instr (6:ii) (8:ii) in
     let BFA = slice_raw instr (11:ii) (13:ii) in
     Just (Mcrf (reset_vector_start BF,reset_vector_start BFA))
  | ((Vector [B0;B1;B0;B0;B0;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;_] _ _) as instr) ->
     let LEV = slice_raw instr (20:ii) (26:ii) in
     Just (Sc (reset_vector_start LEV))
  | ((Vector [B0;B1;B0;B0;B0;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1] _ _) as instr) ->
     let LEV = slice_raw instr (20:ii) (26:ii) in
     Just (Scv (reset_vector_start LEV))
  | ((Vector [B1;B0;B0;B0;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let D = slice_raw instr (16:ii) (31:ii) in
     Just (Lbz (reset_vector_start RT,reset_vector_start RA,reset_vector_start D))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B1;B0;B1;B0;B1;B1;B1;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Lbzx (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B1;B0;B0;B0;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let D = slice_raw instr (16:ii) (31:ii) in
     Just (Lbzu (reset_vector_start RT,reset_vector_start RA,reset_vector_start D))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B1;B1;B1;B0;B1;B1;B1;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Lbzux (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B1;B0;B1;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let D = slice_raw instr (16:ii) (31:ii) in
     Just (Lhz (reset_vector_start RT,reset_vector_start RA,reset_vector_start D))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B0;B0;B0;B1;B0;B1;B1;B1;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Lhzx (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B1;B0;B1;B0;B0;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let D = slice_raw instr (16:ii) (31:ii) in
     Just (Lhzu (reset_vector_start RT,reset_vector_start RA,reset_vector_start D))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B0;B0;B1;B1;B0;B1;B1;B1;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Lhzux (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B1;B0;B1;B0;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let D = slice_raw instr (16:ii) (31:ii) in
     Just (Lha (reset_vector_start RT,reset_vector_start RA,reset_vector_start D))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B0;B1;B0;B1;B0;B1;B1;B1;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Lhax (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B1;B0;B1;B0;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let D = slice_raw instr (16:ii) (31:ii) in
     Just (Lhau (reset_vector_start RT,reset_vector_start RA,reset_vector_start D))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B0;B1;B1;B1;B0;B1;B1;B1;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Lhaux (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B1;B0;B0;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let D = slice_raw instr (16:ii) (31:ii) in
     Just (Lwz (reset_vector_start RT,reset_vector_start RA,reset_vector_start D))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B0;B1;B1;B1;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Lwzx (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B1;B0;B0;B0;B0;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let D = slice_raw instr (16:ii) (31:ii) in
     Just (Lwzu (reset_vector_start RT,reset_vector_start RA,reset_vector_start D))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B1;B1;B0;B1;B1;B1;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Lwzux (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B1;B1;B1;B0;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B0] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let DS = slice_raw instr (16:ii) (29:ii) in
     Just (Lwa (reset_vector_start RT,reset_vector_start RA,reset_vector_start DS))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B0;B1;B0;B1;B0;B1;B0;B1;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Lwax (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B0;B1;B1;B1;B0;B1;B0;B1;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Lwaux (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B1;B1;B1;B0;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let DS = slice_raw instr (16:ii) (29:ii) in
     Just (Ld (reset_vector_start RT,reset_vector_start RA,reset_vector_start DS))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B0;B1;B0;B1;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Ldx (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B1;B1;B1;B0;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let DS = slice_raw instr (16:ii) (29:ii) in
     Just (Ldu (reset_vector_start RT,reset_vector_start RA,reset_vector_start DS))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B1;B1;B0;B1;B0;B1;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Ldux (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B1;B0;B0;B1;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let D = slice_raw instr (16:ii) (31:ii) in
     Just (Stb (reset_vector_start RS,reset_vector_start RA,reset_vector_start D))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;B1;B0;B1;B0;B1;B1;B1;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Stbx (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B1;B0;B0;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let D = slice_raw instr (16:ii) (31:ii) in
     Just (Stbu (reset_vector_start RS,reset_vector_start RA,reset_vector_start D))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;B1;B1;B1;B0;B1;B1;B1;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Stbux (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B1;B0;B1;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let D = slice_raw instr (16:ii) (31:ii) in
     Just (Sth (reset_vector_start RS,reset_vector_start RA,reset_vector_start D))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B1;B0;B0;B1;B0;B1;B1;B1;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Sthx (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B1;B0;B1;B1;B0;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let D = slice_raw instr (16:ii) (31:ii) in
     Just (Sthu (reset_vector_start RS,reset_vector_start RA,reset_vector_start D))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B1;B0;B1;B1;B0;B1;B1;B1;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Sthux (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B1;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let D = slice_raw instr (16:ii) (31:ii) in
     Just (Stw (reset_vector_start RS,reset_vector_start RA,reset_vector_start D))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;B0;B0;B1;B0;B1;B1;B1;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Stwx (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B1;B0;B0;B1;B0;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let D = slice_raw instr (16:ii) (31:ii) in
     Just (Stwu (reset_vector_start RS,reset_vector_start RA,reset_vector_start D))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;B0;B1;B1;B0;B1;B1;B1;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Stwux (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B1;B1;B1;B1;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let DS = slice_raw instr (16:ii) (29:ii) in
     Just (Std (reset_vector_start RS,reset_vector_start RA,reset_vector_start DS))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;B0;B0;B1;B0;B1;B0;B1;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Stdx (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B1;B1;B1;B1;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let DS = slice_raw instr (16:ii) (29:ii) in
     Just (Stdu (reset_vector_start RS,reset_vector_start RA,reset_vector_start DS))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;B0;B1;B1;B0;B1;B0;B1;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Stdux (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B1;B1;B1;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RTp = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let DQ = slice_raw instr (16:ii) (27:ii) in
     let PT = slice_raw instr (28:ii) (31:ii) in
     Just (Lq (reset_vector_start RTp,reset_vector_start RA,reset_vector_start DQ,reset_vector_start PT))
  | ((Vector [B1;B1;B1;B1;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B0] _ _) as instr) ->
     let RSp = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let DS = slice_raw instr (16:ii) (29:ii) in
     Just (Stq (reset_vector_start RSp,reset_vector_start RA,reset_vector_start DS))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B1;B0;B0;B0;B1;B0;B1;B1;B0;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Lhbrx (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B1;B1;B0;B0;B1;B0;B1;B1;B0;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Sthbrx (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B0;B0;B0;B0;B1;B0;B1;B1;B0;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Lwbrx (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B0;B1;B0;B0;B1;B0;B1;B1;B0;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Stwbrx (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B0;B0;B0;B0;B1;B0;B1;B0;B0;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Ldbrx (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B0;B1;B0;B0;B1;B0;B1;B0;B0;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Stdbrx (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B1;B0;B1;B1;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let D = slice_raw instr (16:ii) (31:ii) in
     Just (Lmw (reset_vector_start RT,reset_vector_start RA,reset_vector_start D))
  | ((Vector [B1;B0;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let D = slice_raw instr (16:ii) (31:ii) in
     Just (Stmw (reset_vector_start RS,reset_vector_start RA,reset_vector_start D))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B0;B0;B1;B0;B1;B0;B1;B0;B1;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let NB = slice_raw instr (16:ii) (20:ii) in
     Just (Lswi (reset_vector_start RT,reset_vector_start RA,reset_vector_start NB))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B0;B0;B0;B0;B1;B0;B1;B0;B1;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Lswx (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B0;B1;B1;B0;B1;B0;B1;B0;B1;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let NB = slice_raw instr (16:ii) (20:ii) in
     Just (Stswi (reset_vector_start RS,reset_vector_start RA,reset_vector_start NB))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B0;B1;B0;B0;B1;B0;B1;B0;B1;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Stswx (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B0;B1;B1;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let SI = slice_raw instr (16:ii) (31:ii) in
     Just (Addi (reset_vector_start RT,reset_vector_start RA,reset_vector_start SI))
  | ((Vector [B0;B0;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let SI = slice_raw instr (16:ii) (31:ii) in
     Just (Addis (reset_vector_start RT,reset_vector_start RA,reset_vector_start SI))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B1;B0;B0;B0;B0;B1;B0;B1;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Add (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B0;B0;B0;B1;B0;B1;B0;B0;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Subf (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B0;B1;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let SI = slice_raw instr (16:ii) (31:ii) in
     Just (Addic (reset_vector_start RT,reset_vector_start RA,reset_vector_start SI))
  | ((Vector [B0;B0;B1;B1;B0;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let SI = slice_raw instr (16:ii) (31:ii) in
     Just (AddicDot (reset_vector_start RT,reset_vector_start RA,reset_vector_start SI))
  | ((Vector [B0;B0;B1;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let SI = slice_raw instr (16:ii) (31:ii) in
     Just (Subfic (reset_vector_start RT,reset_vector_start RA,reset_vector_start SI))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B0;B0;B0;B0;B0;B1;B0;B1;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Addc (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B0;B0;B0;B0;B0;B1;B0;B0;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Subfc (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B0;B1;B0;B0;B0;B1;B0;B1;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Adde (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B0;B1;B0;B0;B0;B1;B0;B0;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Subfe (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B0;B1;B1;B1;B0;B1;B0;B1;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     Just (Addme (reset_vector_start RT,reset_vector_start RA,OE,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B0;B1;B1;B1;B0;B1;B0;B0;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     Just (Subfme (reset_vector_start RT,reset_vector_start RA,OE,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B0;B1;B1;B0;B0;B1;B0;B1;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     Just (Addze (reset_vector_start RT,reset_vector_start RA,OE,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B0;B1;B1;B0;B0;B1;B0;B0;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     Just (Subfze (reset_vector_start RT,reset_vector_start RA,OE,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B0;B0;B1;B1;B0;B1;B0;B0;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     Just (Neg (reset_vector_start RT,reset_vector_start RA,OE,Rc))
  | ((Vector [B0;B0;B0;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let SI = slice_raw instr (16:ii) (31:ii) in
     Just (Mulli (reset_vector_start RT,reset_vector_start RA,reset_vector_start SI))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B0;B1;B1;B1;B0;B1;B0;B1;B1;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Mullw (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;B0;B0;B1;B0;B1;B1;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Mulhw (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B0;B1;B1;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Mulhwu (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B1;B1;B1;B1;B0;B1;B0;B1;B1;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Divw (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B1;B1;B1;B0;B0;B1;B0;B1;B1;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Divwu (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B1;B1;B0;B1;B0;B1;B0;B1;B1;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Divwe (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B1;B1;B0;B0;B0;B1;B0;B1;B1;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Divweu (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B0;B1;B1;B1;B0;B1;B0;B0;B1;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Mulld (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;B0;B0;B1;B0;B0;B1;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Mulhd (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B0;B0;B1;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Mulhdu (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B1;B1;B1;B1;B0;B1;B0;B0;B1;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Divd (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B1;B1;B1;B0;B0;B1;B0;B0;B1;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Divdu (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B1;B1;B0;B1;B0;B1;B0;B0;B1;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Divde (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B1;B1;B0;B0;B0;B1;B0;B0;B1;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Divdeu (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B0;B1;B0;B1;B1;_;_;_;_;L;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let BF = slice_raw instr (6:ii) (8:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let SI = slice_raw instr (16:ii) (31:ii) in
     Just (Cmpi (reset_vector_start BF,L,reset_vector_start RA,reset_vector_start SI))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;L;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;_] _ _) as instr) ->
     let BF = slice_raw instr (6:ii) (8:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Cmp (reset_vector_start BF,L,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B0;B1;B0;B1;B0;_;_;_;_;L;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let BF = slice_raw instr (6:ii) (8:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let UI = slice_raw instr (16:ii) (31:ii) in
     Just (Cmpli (reset_vector_start BF,L,reset_vector_start RA,reset_vector_start UI))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;L;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;_] _ _) as instr) ->
     let BF = slice_raw instr (6:ii) (8:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Cmpl (reset_vector_start BF,L,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B1;B1;B1;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     let BC = slice_raw instr (21:ii) (25:ii) in
     Just (Isel (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,reset_vector_start BC))
  | ((Vector [B0;B1;B1;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let UI = slice_raw instr (16:ii) (31:ii) in
     Just (Andi (reset_vector_start RS,reset_vector_start RA,reset_vector_start UI))
  | ((Vector [B0;B1;B1;B1;B0;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let UI = slice_raw instr (16:ii) (31:ii) in
     Just (Andis (reset_vector_start RS,reset_vector_start RA,reset_vector_start UI))
  | ((Vector [B0;B1;B1;B0;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let UI = slice_raw instr (16:ii) (31:ii) in
     Just (Ori (reset_vector_start RS,reset_vector_start RA,reset_vector_start UI))
  | ((Vector [B0;B1;B1;B0;B0;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let UI = slice_raw instr (16:ii) (31:ii) in
     Just (Oris (reset_vector_start RS,reset_vector_start RA,reset_vector_start UI))
  | ((Vector [B0;B1;B1;B0;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let UI = slice_raw instr (16:ii) (31:ii) in
     Just (Xori (reset_vector_start RS,reset_vector_start RA,reset_vector_start UI))
  | ((Vector [B0;B1;B1;B0;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let UI = slice_raw instr (16:ii) (31:ii) in
     Just (Xoris (reset_vector_start RS,reset_vector_start RA,reset_vector_start UI))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B1;B1;B0;B0;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (And (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B0;B0;B1;B1;B1;B1;B0;B0;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Xor (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B1;B1;B0;B1;B1;B1;B0;B0;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Nand (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B1;B0;B1;B1;B1;B1;B0;B0;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Or (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B1;B1;B1;B1;B1;B0;B0;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Nor (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B0;B0;B0;B1;B1;B1;B0;B0;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Eqv (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B1;B1;B1;B1;B0;B0;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Andc (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B1;B0;B0;B1;B1;B1;B0;B0;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Orc (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B1;B1;B0;B1;B1;B1;B0;B1;B0;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     Just (Extsb (reset_vector_start RS,reset_vector_start RA,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B1;B1;B0;B0;B1;B1;B0;B1;B0;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     Just (Extsh (reset_vector_start RS,reset_vector_start RA,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B1;B0;B1;B0;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     Just (Cntlzw (reset_vector_start RS,reset_vector_start RA,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B1;B1;B1;B1;B1;B1;B0;B0;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Cmpb (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B1;B1;B1;B1;B0;B1;B0;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     Just (Popcntb (reset_vector_start RS,reset_vector_start RA))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B0;B1;B1;B1;B1;B0;B1;B0;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     Just (Popcntw (reset_vector_start RS,reset_vector_start RA))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;B0;B1;B1;B1;B0;B1;B0;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     Just (Prtyd (reset_vector_start RS,reset_vector_start RA))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;B0;B0;B1;B1;B0;B1;B0;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     Just (Prtyw (reset_vector_start RS,reset_vector_start RA))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B1;B1;B1;B0;B1;B1;B0;B1;B0;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     Just (Extsw (reset_vector_start RS,reset_vector_start RA,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B1;B1;B1;B0;B1;B0;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     Just (Cntlzd (reset_vector_start RS,reset_vector_start RA,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B1;B1;B1;B1;B1;B0;B1;B0;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     Just (Popcntd (reset_vector_start RS,reset_vector_start RA))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;B1;B1;B1;B1;B1;B0;B0;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Bpermd (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B1;B0;B1;B0;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let SH = slice_raw instr (16:ii) (20:ii) in
     let MB = slice_raw instr (21:ii) (25:ii) in
     let ME = slice_raw instr (26:ii) (30:ii) in
     Just (Rlwinm (reset_vector_start RS,reset_vector_start RA,reset_vector_start SH,reset_vector_start MB,reset_vector_start ME,Rc))
  | ((Vector [B0;B1;B0;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     let MB = slice_raw instr (21:ii) (25:ii) in
     let ME = slice_raw instr (26:ii) (30:ii) in
     Just (Rlwnm (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB,reset_vector_start MB,reset_vector_start ME,Rc))
  | ((Vector [B0;B1;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let SH = slice_raw instr (16:ii) (20:ii) in
     let MB = slice_raw instr (21:ii) (25:ii) in
     let ME = slice_raw instr (26:ii) (30:ii) in
     Just (Rlwimi (reset_vector_start RS,reset_vector_start RA,reset_vector_start SH,reset_vector_start MB,reset_vector_start ME,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;_;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let mb = slice_raw instr (21:ii) (26:ii) in
     Just (Rldicl (reset_vector_start RS,reset_vector_start RA,reset_vector_start ((slice instr
                                                                                      (16:ii)
                                                                                        (20:ii)) ^^
                                                                                   (slice instr
                                                                                      (30:ii)
                                                                                        (30:ii))),reset_vector_start mb,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;_;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let me = slice_raw instr (21:ii) (26:ii) in
     Just (Rldicr (reset_vector_start RS,reset_vector_start RA,reset_vector_start ((slice instr
                                                                                      (16:ii)
                                                                                        (20:ii)) ^^
                                                                                   (slice instr
                                                                                      (30:ii)
                                                                                        (30:ii))),reset_vector_start me,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B0;_;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let mb = slice_raw instr (21:ii) (26:ii) in
     Just (Rldic (reset_vector_start RS,reset_vector_start RA,reset_vector_start ((slice instr
                                                                                     (16:ii) (20:ii)) ^^
                                                                                  (slice instr
                                                                                     (30:ii) (30:ii))),reset_vector_start mb,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B0;B0;B0;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     let mb = slice_raw instr (21:ii) (26:ii) in
     Just (Rldcl (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB,reset_vector_start mb,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B0;B0;B1;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     let me = slice_raw instr (21:ii) (26:ii) in
     Just (Rldcr (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB,reset_vector_start me,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B1;_;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let mb = slice_raw instr (21:ii) (26:ii) in
     Just (Rldimi (reset_vector_start RS,reset_vector_start RA,reset_vector_start ((slice instr
                                                                                      (16:ii)
                                                                                        (20:ii)) ^^
                                                                                   (slice instr
                                                                                      (30:ii)
                                                                                        (30:ii))),reset_vector_start mb,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B1;B0;B0;B0;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Slw (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B0;B0;B0;B0;B1;B1;B0;B0;B0;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Srw (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B1;B0;B0;B1;B1;B1;B0;B0;B0;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let SH = slice_raw instr (16:ii) (20:ii) in
     Just (Srawi (reset_vector_start RS,reset_vector_start RA,reset_vector_start SH,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B1;B0;B0;B0;B1;B1;B0;B0;B0;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Sraw (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B1;B0;B1;B1;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Sld (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B0;B0;B0;B0;B1;B1;B0;B1;B1;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Srd (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B1;B0;B0;B1;B1;B1;B0;B1;_;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     Just (Sradi (reset_vector_start RS,reset_vector_start RA,reset_vector_start ((slice instr
                                                                                     (16:ii) (20:ii)) ^^
                                                                                  (slice instr
                                                                                     (30:ii) (30:ii))),Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B1;B0;B0;B0;B1;B1;B0;B1;B0;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Srad (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B0;B0;B0;B1;B1;B0;B1;B0;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     Just (Cdtbcd (reset_vector_start RS,reset_vector_start RA))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B0;B0;B1;B1;B1;B0;B1;B0;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     Just (Cbcdtd (reset_vector_start RS,reset_vector_start RA))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;B0;B0;B1;B0;B1;B0;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Addg6s (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B1;B1;B0;B1;B0;B0;B1;B1;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let spr = slice_raw instr (11:ii) (20:ii) in
     Just (Mtspr (reset_vector_start RS,reset_vector_start spr))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B0;B1;B0;B1;B0;B0;B1;B1;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let spr = slice_raw instr (11:ii) (20:ii) in
     Just (Mfspr (reset_vector_start RT,reset_vector_start spr))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;B0;_;_;_;_;_;_;_;_;_;B0;B0;B1;B0;B0;B1;B0;B0;B0;B0;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let FXM = slice_raw instr (12:ii) (19:ii) in
     Just (Mtcrf (reset_vector_start RS,reset_vector_start FXM))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;B0;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B0;B0;B1;B1;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     Just (Mfcr (reset_vector_start RT))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;B1;_;_;_;_;_;_;_;_;_;B0;B0;B1;B0;B0;B1;B0;B0;B0;B0;_] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let FXM = slice_raw instr (12:ii) (19:ii) in
     Just (Mtocrf (reset_vector_start RS,reset_vector_start FXM))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;B1;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B0;B0;B1;B1;_] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let FXM = slice_raw instr (12:ii) (19:ii) in
     Just (Mfocrf (reset_vector_start RT,reset_vector_start FXM))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;_] _ _) as instr) ->
     let BF = slice_raw instr (6:ii) (8:ii) in
     Just (Mcrxr (reset_vector_start BF))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B1;B0;B0;B1;B1;B1;B0;Rc] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Dlmzb (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B0;B1;B0;B1;B0;B1;B1;B0;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Macchw (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B0;B1;B1;B1;B0;B1;B1;B0;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Macchws (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B0;B1;B0;B0;B0;B1;B1;B0;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Macchwu (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B0;B1;B1;B0;B0;B1;B1;B0;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Macchwsu (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B0;B0;B0;B1;B0;B1;B1;B0;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Machhw (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B0;B0;B1;B1;B0;B1;B1;B0;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Machhws (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B0;B0;B0;B0;B0;B1;B1;B0;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Machhwu (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B0;B0;B1;B0;B0;B1;B1;B0;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Machhwsu (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B1;B1;B0;B1;B0;B1;B1;B0;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Maclhw (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B1;B1;B1;B1;B0;B1;B1;B0;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Maclhws (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B1;B1;B0;B0;B0;B1;B1;B0;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Maclhwu (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B1;B1;B1;B0;B0;B1;B1;B0;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Maclhwsu (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;B0;B1;B0;B1;B0;B0;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Mulchw (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;B0;B0;B0;B1;B0;B0;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Mulchwu (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B1;B0;B1;B0;B0;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Mulhhw (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Mulhhwu (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B1;B0;B1;B0;B1;B0;B0;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Mullhw (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B1;B0;B0;B0;B1;B0;B0;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Mullhwu (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,Rc))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B0;B1;B0;B1;B0;B1;B1;B1;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Nmacchw (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B0;B1;B1;B1;B0;B1;B1;B1;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Nmacchws (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B0;B0;B0;B1;B0;B1;B1;B1;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Nmachhw (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B0;B0;B1;B1;B0;B1;B1;B1;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Nmachhws (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B1;B1;B0;B1;B0;B1;B1;B1;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Nmaclhw (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B0;B0;B1;B0;B0;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;OE;B1;B1;B1;B1;B0;B1;B1;B1;B0;Rc] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Nmaclhws (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,OE,Rc))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B1;B1;B1;B0;B1;B0;B1;B1;B0;_] _ _) as instr) ->
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Icbi (reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B0;B1;B1;B0;_] _ _) as instr) ->
     let CT = slice_raw instr (7:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Icbt (reset_vector_start CT,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B0;B1;B1;B1;B1;B0;B1;B1;B0;_] _ _) as instr) ->
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Dcba (reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B1;B0;B0;B0;B1;B0;B1;B1;B0;_] _ _) as instr) ->
     let TH = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Dcbt (reset_vector_start TH,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;B1;B1;B1;B0;B1;B1;B0;_] _ _) as instr) ->
     let TH = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Dcbtst (reset_vector_start TH,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B1;B1;B1;B1;B1;B0;B1;B1;B0;_] _ _) as instr) ->
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Dcbz (reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B1;B1;B0;B1;B1;B0;_] _ _) as instr) ->
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Dcbst (reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B1;B0;B1;B0;B1;B1;B0;_] _ _) as instr) ->
     let L = slice_raw instr (9:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Dcbf (reset_vector_start L,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B1;B0;B0;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;B0;B0;B1;B0;B1;B1;B0;_] _ _) as instr) ->
     Just (Isync)
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B1;B1;B0;B1;B0;B0;EH] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Lbarx (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,EH))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B1;B1;B1;B0;B1;B0;B0;EH] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Lharx (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,EH))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B0;B1;B0;B1;B0;B0;EH] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Lwarx (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,EH))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B0;B1;B0;B1;B1;B0;B1;B1;B0;B1] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Stbcx (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B0;B1;B1;B0;B1;B0;B1;B1;B0;B1] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Sthcx (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;B0;B0;B1;B0;B1;B1;B0;B1] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Stwcx (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B1;B0;B1;B0;B1;B0;B0;EH] _ _) as instr) ->
     let RT = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Ldarx (reset_vector_start RT,reset_vector_start RA,reset_vector_start RB,EH))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B1;B1;B0;B1;B0;B1;B1;B0;B1] _ _) as instr) ->
     let RS = slice_raw instr (6:ii) (10:ii) in
     let RA = slice_raw instr (11:ii) (15:ii) in
     let RB = slice_raw instr (16:ii) (20:ii) in
     Just (Stdcx (reset_vector_start RS,reset_vector_start RA,reset_vector_start RB))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B0;B0;B1;B0;B1;B0;B1;B1;B0;_] _ _) as instr) ->
     let L = slice_raw instr (9:ii) (10:ii) in
     Just (Sync (reset_vector_start L))
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B1;B1;B0;B1;B0;B1;B0;B1;B1;B0;_] _ _) as instr) ->
     Just (Eieio)
  | ((Vector [B0;B1;B1;B1;B1;B1;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;B0;B0;B0;B0;B1;B1;B1;B1;B1;B0;_] _ _) as instr) ->
     let WC = slice_raw instr (9:ii) (10:ii) in
     Just (Wait (reset_vector_start WC))
  | _ -> Nothing
  end

let illegal_instructions instr =
  if bitU_to_bool (illegal_instructions_pred instr)
  then Nothing
  else Just instr

let recalculate_lswx_reg_footprint instr =
  let iR = [] in
  let oR = [] in
  let Nias = [NIAFP_successor] in
  let Dia = DIAFP_none in
  let ik = IK_mem_read Read_plain in
  let (RT, RA, RB) = match instr with | Lswx (RT,RA,RB) -> (RT,RA,RB) end in
  let iR =
    if bitU_to_bool (eq_vec_range (RA, (0:ii)))
    then iR
    else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
  let r = (0:ii) in
  let iR =
    (RFull (access GPRs (unsigned (reset_vector_start RB)))) ::
      (RSlice ("XER",(57:ii),(63:ii))) :: iR in
  let aR = iR in
  let r = minus_VII (reset_vector_start RT) (1:ii) in
  let i = (32:ii) in
  read_reg_range XER (57:ii) (63:ii) >>= fun w__0 ->
  let n_top = unsigned (reset_vector_start w__0) in
  let (r, oR) =
    if bitU_to_bool (eq_range (n_top, (0:ii)))
    then
      let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
      (r,oR)
    else
      let j = (0:ii) in
      let n_r = quot n_top (4:ii) in
      let n_mod = modulo n_top (4:ii) in
      let n_r = if bitU_to_bool (eq_range (n_mod, (0:ii))) then n_r else n_r + (1:ii) in
      let (oR, j, r) =
        (foreach_dec (n_r,(1:ii),(1:ii)) (oR,j,r)
          (fun n (oR,j,r) ->
           let r = modulo (r + (1:ii)) (32:ii) in
           let j = j + (32:ii) in
           let oR = (RFull (access GPRs r)) :: oR in
           (oR,j,r))) in
      (r,oR) in
  return (iR,oR,aR,Nias,Dia,ik)

let recalculate_stswx_reg_footprint instr =
  let iR = [] in
  let oR = [] in
  let Nias = [NIAFP_successor] in
  let Dia = DIAFP_none in
  let ik = IK_mem_write Write_plain in
  let (RS, RA, RB) = match instr with | Stswx (RS,RA,RB) -> (RS,RA,RB) end in
  let iR =
    if bitU_to_bool (eq_vec_range (RA, (0:ii)))
    then iR
    else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
  let r = (0:ii) in
  let iR =
    (RFull (access GPRs (unsigned (reset_vector_start RB)))) ::
      (RSlice ("XER",(57:ii),(63:ii))) :: iR in
  let aR = iR in
  let r = minus_VII (reset_vector_start RS) (1:ii) in
  let i = (32:ii) in
  read_reg_range XER (57:ii) (63:ii) >>= fun w__0 ->
  let n_top = unsigned (reset_vector_start w__0) in
  let j = (0:ii) in
  let (j, i, iR, r) =
    (foreach_dec (n_top,(1:ii),(1:ii)) (j,i,iR,r)
      (fun n (j,i,iR,r) ->
       let r = if bitU_to_bool (eq_range (i, (32:ii))) then modulo (r + (1:ii)) (32:ii) else r in
       let iR = (RSlice (access GPRs r,i,i + (7:ii))) :: iR in
       let i = i + (8:ii) in
       let j = j + (8:ii) in
       let i = if bitU_to_bool (eq_range (i, (64:ii))) then (32:ii) else i in
       (j,i,iR,r))) in
  let ik = IK_mem_write Write_plain in
  return (iR,oR,aR,Nias,Dia,ik)



let execute_B (LI, AA, LK) =
  (if bitU_to_bool AA
   then
     write_reg
       NIA
       (set_vector_start 0 (exts ((64:ii),reset_vector_start (LI ^^ (Vector [B0;B0] 0 true)))))
   else
     read_reg CIA >>= fun w__0 ->
     write_reg
       NIA
       (set_vector_start 0
         (add_VVV
            w__0
            (reset_vector_start (exts ((64:ii),reset_vector_start (LI ^^ (Vector [B0;B0] 0 true)))))))) >>
  if bitU_to_bool LK
  then
    read_reg CIA >>= fun w__1 ->
    write_reg LR (set_vector_start 0 (add_VIV w__1 (4:ii)))
  else return ()

let execute_Bc (BO, BI, BD, AA, LK) =
  let M = (0:ii) in
  read_reg mode64bit >>= fun w__0 ->
  let M = if bitU_to_bool (most_significant w__0) then (0:ii) else (32:ii) in
  read_reg CTR >>= fun ctr_temp ->
  (if bitU_to_bool (~(access BO (2:ii)))
   then
     let ctr_temp = set_vector_start 0 (minus_VIV (reset_vector_start ctr_temp) (1:ii)) in
     write_reg CTR ctr_temp >>
     return ctr_temp
   else return ctr_temp) >>= fun ctr_temp ->
  let ctr_ok =
    (access BO (2:ii)) |.
      ((~(eq_vec_range (slice ctr_temp M (63:ii), (0:ii)))) +. (access BO (3:ii))) in
  read_reg_bit CR (add_VII (reset_vector_start BI) (32:ii)) >>= fun w__1 ->
  let cond_ok = (access BO (0:ii)) |. (w__1 +. (~(access BO (1:ii)))) in
  (if bitU_to_bool (ctr_ok &. cond_ok)
   then
     if bitU_to_bool AA
     then
       write_reg
         NIA
         (set_vector_start 0 (exts ((64:ii),reset_vector_start (BD ^^ (Vector [B0;B0] 0 true)))))
     else
       read_reg CIA >>= fun w__2 ->
       write_reg
         NIA
         (set_vector_start 0
           (add_VVV
              w__2
              (reset_vector_start (exts ((64:ii),reset_vector_start (BD ^^ (Vector [B0;B0] 0 true)))))))
   else return ()) >>
  if bitU_to_bool LK
  then
    read_reg CIA >>= fun w__3 ->
    write_reg LR (set_vector_start 0 (add_VIV w__3 (4:ii)))
  else return ()

let execute_Bclr (BO, BI, BH, LK) =
  let M = (0:ii) in
  read_reg mode64bit >>= fun w__0 ->
  let M = if bitU_to_bool (most_significant w__0) then (0:ii) else (32:ii) in
  read_reg CTR >>= fun ctr_temp ->
  (if bitU_to_bool (~(access BO (2:ii)))
   then
     let ctr_temp = set_vector_start 0 (minus_VIV (reset_vector_start ctr_temp) (1:ii)) in
     write_reg CTR ctr_temp >>
     return ctr_temp
   else return ctr_temp) >>= fun ctr_temp ->
  let ctr_ok =
    (access BO (2:ii)) |.
      ((~(eq_vec_range (slice ctr_temp M (63:ii), (0:ii)))) +. (access BO (3:ii))) in
  read_reg_bit CR (add_VII (reset_vector_start BI) (32:ii)) >>= fun w__1 ->
  let cond_ok = (access BO (0:ii)) |. (w__1 +. (~(access BO (1:ii)))) in
  (if bitU_to_bool (ctr_ok &. cond_ok)
   then
     read_reg_range LR (0:ii) (61:ii) >>= fun w__2 ->
     write_reg NIA (w__2 ^^ (Vector [B0;B0] 0 true))
   else return ()) >>
  if bitU_to_bool LK
  then
    read_reg CIA >>= fun w__3 ->
    write_reg LR (set_vector_start 0 (add_VIV w__3 (4:ii)))
  else return ()

let execute_Bcctr (BO, BI, BH, LK) =
  read_reg_bit CR (add_VII (reset_vector_start BI) (32:ii)) >>= fun w__0 ->
  let cond_ok = (access BO (0:ii)) |. (w__0 +. (~(access BO (1:ii)))) in
  (if bitU_to_bool cond_ok
   then
     read_reg_range CTR (0:ii) (61:ii) >>= fun w__1 ->
     write_reg NIA (w__1 ^^ (Vector [B0;B0] 0 true))
   else return ()) >>
  if bitU_to_bool LK
  then
    read_reg CIA >>= fun w__2 ->
    write_reg LR (set_vector_start 0 (add_VIV w__2 (4:ii)))
  else return ()

let execute_Crand (BT, BA, BB) =
  read_reg_bit CR (add_VII (reset_vector_start BA) (32:ii)) >>= fun w__0 ->
  read_reg_bit CR (add_VII (reset_vector_start BB) (32:ii)) >>= fun w__1 ->
  write_reg_bit CR (add_VII (reset_vector_start BT) (32:ii)) (w__0 &. w__1)

let execute_Crnand (BT, BA, BB) =
  read_reg_bit CR (add_VII (reset_vector_start BA) (32:ii)) >>= fun w__0 ->
  read_reg_bit CR (add_VII (reset_vector_start BB) (32:ii)) >>= fun w__1 ->
  write_reg_bit CR (add_VII (reset_vector_start BT) (32:ii)) (~(w__0 &. w__1))

let execute_Cror (BT, BA, BB) =
  read_reg_bit CR (add_VII (reset_vector_start BA) (32:ii)) >>= fun w__0 ->
  read_reg_bit CR (add_VII (reset_vector_start BB) (32:ii)) >>= fun w__1 ->
  write_reg_bit CR (add_VII (reset_vector_start BT) (32:ii)) (w__0 |. w__1)

let execute_Crxor (BT, BA, BB) =
  read_reg_bit CR (add_VII (reset_vector_start BA) (32:ii)) >>= fun w__0 ->
  read_reg_bit CR (add_VII (reset_vector_start BB) (32:ii)) >>= fun w__1 ->
  write_reg_bit CR (add_VII (reset_vector_start BT) (32:ii)) (w__0 +. w__1)

let execute_Crnor (BT, BA, BB) =
  read_reg_bit CR (add_VII (reset_vector_start BA) (32:ii)) >>= fun w__0 ->
  read_reg_bit CR (add_VII (reset_vector_start BB) (32:ii)) >>= fun w__1 ->
  write_reg_bit CR (add_VII (reset_vector_start BT) (32:ii)) (~(w__0 |. w__1))

let execute_Creqv (BT, BA, BB) =
  read_reg_bit CR (add_VII (reset_vector_start BA) (32:ii)) >>= fun w__0 ->
  read_reg_bit CR (add_VII (reset_vector_start BB) (32:ii)) >>= fun w__1 ->
  write_reg_bit CR (add_VII (reset_vector_start BT) (32:ii)) (w__0 +. (~w__1))

let execute_Crandc (BT, BA, BB) =
  read_reg_bit CR (add_VII (reset_vector_start BA) (32:ii)) >>= fun w__0 ->
  read_reg_bit CR (add_VII (reset_vector_start BB) (32:ii)) >>= fun w__1 ->
  write_reg_bit CR (add_VII (reset_vector_start BT) (32:ii)) (w__0 &. (~w__1))

let execute_Crorc (BT, BA, BB) =
  read_reg_bit CR (add_VII (reset_vector_start BA) (32:ii)) >>= fun w__0 ->
  read_reg_bit CR (add_VII (reset_vector_start BB) (32:ii)) >>= fun w__1 ->
  write_reg_bit CR (add_VII (reset_vector_start BT) (32:ii)) (w__0 |. (~w__1))

let execute_Mcrf (BF, BFA) =
  read_reg_range CR
    (add_VII (reset_vector_start (mult_IVV (4:ii) (reset_vector_start BFA))) (32:ii))
      (add_VII (reset_vector_start (mult_IVV (4:ii) (reset_vector_start BFA))) (35:ii)) >>= fun w__0 ->
  write_reg_range
    CR (add_VII (reset_vector_start (mult_IVV (4:ii) (reset_vector_start BF))) (32:ii))
    (add_VII (reset_vector_start (mult_IVV (4:ii) (reset_vector_start BF))) (35:ii))
    w__0

let execute_Sc LEV = return ()

let execute_Scv LEV = return ()

let execute_Lbz (RT, RA, D) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  let EA =
    set_vector_start 0
      (add_VVV (reset_vector_start b) (reset_vector_start (exts ((64:ii),reset_vector_start D)))) in
  MEMr (reset_vector_start EA,(1:ii)) >>= fun w__1 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) ^^
     w__1)

let execute_Lbzx (RT, RA, RB) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  MEMr (reset_vector_start EA,(1:ii)) >>= fun w__2 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) ^^
     w__2)

let execute_Lbzu (RT, RA, D) =
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  let EA =
    set_vector_start 0
      (add_VVV (reset_vector_start w__0) (reset_vector_start (exts ((64:ii),reset_vector_start D)))) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) EA >>
  MEMr (reset_vector_start EA,(1:ii)) >>= fun w__1 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) ^^
     w__1)

let execute_Lbzux (RT, RA, RB) =
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start w__0) (reset_vector_start w__1)) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) EA >>
  MEMr (reset_vector_start EA,(1:ii)) >>= fun w__2 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) ^^
     w__2)

let execute_Lhz (RT, RA, D) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  let EA =
    set_vector_start 0
      (add_VVV (reset_vector_start b) (reset_vector_start (exts ((64:ii),reset_vector_start D)))) in
  MEMr (reset_vector_start EA,(2:ii)) >>= fun w__1 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0] 0 true) ^^
     w__1)

let execute_Lhzx (RT, RA, RB) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  MEMr (reset_vector_start EA,(2:ii)) >>= fun w__2 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0] 0 true) ^^
     w__2)

let execute_Lhzu (RT, RA, D) =
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  let EA =
    set_vector_start 0
      (add_VVV (reset_vector_start w__0) (reset_vector_start (exts ((64:ii),reset_vector_start D)))) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) EA >>
  MEMr (reset_vector_start EA,(2:ii)) >>= fun w__1 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0] 0 true) ^^
     w__1)

let execute_Lhzux (RT, RA, RB) =
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start w__0) (reset_vector_start w__1)) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) EA >>
  MEMr (reset_vector_start EA,(2:ii)) >>= fun w__2 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0] 0 true) ^^
     w__2)

let execute_Lha (RT, RA, D) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  let EA =
    set_vector_start 0
      (add_VVV (reset_vector_start b) (reset_vector_start (exts ((64:ii),reset_vector_start D)))) in
  MEMr (reset_vector_start EA,(2:ii)) >>= fun w__1 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    (set_vector_start 0 (exts ((64:ii),reset_vector_start w__1)))

let execute_Lhax (RT, RA, RB) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  MEMr (reset_vector_start EA,(2:ii)) >>= fun w__2 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    (set_vector_start 0 (exts ((64:ii),reset_vector_start w__2)))

let execute_Lhau (RT, RA, D) =
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  let EA =
    set_vector_start 0
      (add_VVV (reset_vector_start w__0) (reset_vector_start (exts ((64:ii),reset_vector_start D)))) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) EA >>
  MEMr (reset_vector_start EA,(2:ii)) >>= fun w__1 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    (set_vector_start 0 (exts ((64:ii),reset_vector_start w__1)))

let execute_Lhaux (RT, RA, RB) =
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start w__0) (reset_vector_start w__1)) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) EA >>
  MEMr (reset_vector_start EA,(2:ii)) >>= fun w__2 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    (set_vector_start 0 (exts ((64:ii),reset_vector_start w__2)))

let execute_Lwz (RT, RA, D) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  let EA =
    set_vector_start 0
      (add_VVV (reset_vector_start b) (reset_vector_start (exts ((64:ii),reset_vector_start D)))) in
  MEMr (reset_vector_start EA,(4:ii)) >>= fun w__1 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) ^^
     w__1)

let execute_Lwzx (RT, RA, RB) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  MEMr (reset_vector_start EA,(4:ii)) >>= fun w__2 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) ^^
     w__2)

let execute_Lwzu (RT, RA, D) =
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  let EA =
    set_vector_start 0
      (add_VVV (reset_vector_start w__0) (reset_vector_start (exts ((64:ii),reset_vector_start D)))) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) EA >>
  MEMr (reset_vector_start EA,(4:ii)) >>= fun w__1 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) ^^
     w__1)

let execute_Lwzux (RT, RA, RB) =
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start w__0) (reset_vector_start w__1)) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) EA >>
  MEMr (reset_vector_start EA,(4:ii)) >>= fun w__2 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) ^^
     w__2)

let execute_Lwa (RT, RA, DS) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  let EA =
    set_vector_start 0
      (add_VVV
         (reset_vector_start b)
         (reset_vector_start (exts ((64:ii),reset_vector_start (DS ^^ (Vector [B0;B0] 0 true)))))) in
  MEMr (reset_vector_start EA,(4:ii)) >>= fun w__1 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    (set_vector_start 0 (exts ((64:ii),reset_vector_start w__1)))

let execute_Lwax (RT, RA, RB) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  MEMr (reset_vector_start EA,(4:ii)) >>= fun w__2 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    (set_vector_start 0 (exts ((64:ii),reset_vector_start w__2)))

let execute_Lwaux (RT, RA, RB) =
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start w__0) (reset_vector_start w__1)) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) EA >>
  MEMr (reset_vector_start EA,(4:ii)) >>= fun w__2 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    (set_vector_start 0 (exts ((64:ii),reset_vector_start w__2)))

let execute_Ld (RT, RA, DS) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  let EA =
    set_vector_start 0
      (add_VVV
         (reset_vector_start b)
         (reset_vector_start (exts ((64:ii),reset_vector_start (DS ^^ (Vector [B0;B0] 0 true)))))) in
  MEMr (reset_vector_start EA,(8:ii)) >>= fun w__1 ->
  write_reg (access GPR (unsigned (reset_vector_start RT))) w__1

let execute_Ldx (RT, RA, RB) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  MEMr (reset_vector_start EA,(8:ii)) >>= fun w__2 ->
  write_reg (access GPR (unsigned (reset_vector_start RT))) w__2

let execute_Ldu (RT, RA, DS) =
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  let EA =
    set_vector_start 0
      (add_VVV
         (reset_vector_start w__0)
         (reset_vector_start (exts ((64:ii),reset_vector_start (DS ^^ (Vector [B0;B0] 0 true)))))) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) EA >>
  MEMr (reset_vector_start EA,(8:ii)) >>= fun w__1 ->
  write_reg (access GPR (unsigned (reset_vector_start RT))) w__1

let execute_Ldux (RT, RA, RB) =
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start w__0) (reset_vector_start w__1)) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) EA >>
  MEMr (reset_vector_start EA,(8:ii)) >>= fun w__2 ->
  write_reg (access GPR (unsigned (reset_vector_start RT))) w__2

let execute_Stb (RS, RA, D) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  let EA =
    set_vector_start 0
      (add_VVV (reset_vector_start b) (reset_vector_start (exts ((64:ii),reset_vector_start D)))) in
  MEMw_EA (reset_vector_start EA,(1:ii)) >>
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (56:ii) (63:ii) >>= fun w__1 ->
  MEMw (reset_vector_start EA,(1:ii),reset_vector_start (set_vector_start 0 w__1))

let execute_Stbx (RS, RA, RB) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  MEMw_EA (reset_vector_start EA,(1:ii)) >>
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (56:ii) (63:ii) >>= fun w__2 ->
  MEMw (reset_vector_start EA,(1:ii),reset_vector_start (set_vector_start 0 w__2))

let execute_Stbu (RS, RA, D) =
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  let EA =
    set_vector_start 0
      (add_VVV (reset_vector_start w__0) (reset_vector_start (exts ((64:ii),reset_vector_start D)))) in
  MEMw_EA (reset_vector_start EA,(1:ii)) >>
  write_reg (access GPR (unsigned (reset_vector_start RA))) EA >>
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (56:ii) (63:ii) >>= fun w__1 ->
  MEMw (reset_vector_start EA,(1:ii),reset_vector_start (set_vector_start 0 w__1))

let execute_Stbux (RS, RA, RB) =
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start w__0) (reset_vector_start w__1)) in
  MEMw_EA (reset_vector_start EA,(1:ii)) >>
  write_reg (access GPR (unsigned (reset_vector_start RA))) EA >>
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (56:ii) (63:ii) >>= fun w__2 ->
  MEMw (reset_vector_start EA,(1:ii),reset_vector_start (set_vector_start 0 w__2))

let execute_Sth (RS, RA, D) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  let EA =
    set_vector_start 0
      (add_VVV (reset_vector_start b) (reset_vector_start (exts ((64:ii),reset_vector_start D)))) in
  MEMw_EA (reset_vector_start EA,(2:ii)) >>
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (48:ii) (63:ii) >>= fun w__1 ->
  MEMw (reset_vector_start EA,(2:ii),reset_vector_start (set_vector_start 0 w__1))

let execute_Sthx (RS, RA, RB) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  MEMw_EA (reset_vector_start EA,(2:ii)) >>
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (48:ii) (63:ii) >>= fun w__2 ->
  MEMw (reset_vector_start EA,(2:ii),reset_vector_start (set_vector_start 0 w__2))

let execute_Sthu (RS, RA, D) =
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  let EA =
    set_vector_start 0
      (add_VVV (reset_vector_start w__0) (reset_vector_start (exts ((64:ii),reset_vector_start D)))) in
  MEMw_EA (reset_vector_start EA,(2:ii)) >>
  write_reg (access GPR (unsigned (reset_vector_start RA))) EA >>
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (48:ii) (63:ii) >>= fun w__1 ->
  MEMw (reset_vector_start EA,(2:ii),reset_vector_start (set_vector_start 0 w__1))

let execute_Sthux (RS, RA, RB) =
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start w__0) (reset_vector_start w__1)) in
  MEMw_EA (reset_vector_start EA,(2:ii)) >>
  write_reg (access GPR (unsigned (reset_vector_start RA))) EA >>
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (48:ii) (63:ii) >>= fun w__2 ->
  MEMw (reset_vector_start EA,(2:ii),reset_vector_start (set_vector_start 0 w__2))

let execute_Stw (RS, RA, D) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  let EA =
    set_vector_start 0
      (add_VVV (reset_vector_start b) (reset_vector_start (exts ((64:ii),reset_vector_start D)))) in
  MEMw_EA (reset_vector_start EA,(4:ii)) >>
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (32:ii) (63:ii) >>= fun w__1 ->
  MEMw (reset_vector_start EA,(4:ii),reset_vector_start (set_vector_start 0 w__1))

let execute_Stwx (RS, RA, RB) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  MEMw_EA (reset_vector_start EA,(4:ii)) >>
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (32:ii) (63:ii) >>= fun w__2 ->
  MEMw (reset_vector_start EA,(4:ii),reset_vector_start (set_vector_start 0 w__2))

let execute_Stwu (RS, RA, D) =
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  let EA =
    set_vector_start 0
      (add_VVV (reset_vector_start w__0) (reset_vector_start (exts ((64:ii),reset_vector_start D)))) in
  MEMw_EA (reset_vector_start EA,(4:ii)) >>
  write_reg (access GPR (unsigned (reset_vector_start RA))) EA >>
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (32:ii) (63:ii) >>= fun w__1 ->
  MEMw (reset_vector_start EA,(4:ii),reset_vector_start (set_vector_start 0 w__1))

let execute_Stwux (RS, RA, RB) =
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start w__0) (reset_vector_start w__1)) in
  MEMw_EA (reset_vector_start EA,(4:ii)) >>
  write_reg (access GPR (unsigned (reset_vector_start RA))) EA >>
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (32:ii) (63:ii) >>= fun w__2 ->
  MEMw (reset_vector_start EA,(4:ii),reset_vector_start (set_vector_start 0 w__2))

let execute_Std (RS, RA, DS) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  let EA =
    set_vector_start 0
      (add_VVV
         (reset_vector_start b)
         (reset_vector_start (exts ((64:ii),reset_vector_start (DS ^^ (Vector [B0;B0] 0 true)))))) in
  MEMw_EA (reset_vector_start EA,(8:ii)) >>
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__1 ->
  MEMw (reset_vector_start EA,(8:ii),reset_vector_start w__1)

let execute_Stdx (RS, RA, RB) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  MEMw_EA (reset_vector_start EA,(8:ii)) >>
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__2 ->
  MEMw (reset_vector_start EA,(8:ii),reset_vector_start w__2)

let execute_Stdu (RS, RA, DS) =
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  let EA =
    set_vector_start 0
      (add_VVV
         (reset_vector_start w__0)
         (reset_vector_start (exts ((64:ii),reset_vector_start (DS ^^ (Vector [B0;B0] 0 true)))))) in
  MEMw_EA (reset_vector_start EA,(8:ii)) >>
  write_reg (access GPR (unsigned (reset_vector_start RA))) EA >>
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__1 ->
  MEMw (reset_vector_start EA,(8:ii),reset_vector_start w__1)

let execute_Stdux (RS, RA, RB) =
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start w__0) (reset_vector_start w__1)) in
  MEMw_EA (reset_vector_start EA,(8:ii)) >>
  write_reg (access GPR (unsigned (reset_vector_start RA))) EA >>
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__2 ->
  MEMw (reset_vector_start EA,(8:ii),reset_vector_start w__2)

let execute_Lhbrx (RT, RA, RB) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  MEMr (reset_vector_start EA,(2:ii)) >>= fun load_data ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0] 0 true) ^^
     ((slice load_data (8:ii) (15:ii)) ^^ (slice load_data (0:ii) (7:ii))))

let execute_Sthbrx (RS, RA, RB) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  MEMw_EA (reset_vector_start EA,(2:ii)) >>
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (56:ii) (63:ii) >>= fun w__2 ->
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (48:ii) (55:ii) >>= fun w__3 ->
  MEMw (reset_vector_start EA,(2:ii),reset_vector_start (w__2 ^^ w__3))

let execute_Lwbrx (RT, RA, RB) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  MEMr (reset_vector_start EA,(4:ii)) >>= fun load_data ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) ^^
     ((slice load_data (24:ii) (31:ii)) ^^
      ((slice load_data (16:ii) (23:ii)) ^^
       ((slice load_data (8:ii) (15:ii)) ^^ (slice load_data (0:ii) (7:ii))))))

let execute_Stwbrx (RS, RA, RB) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  MEMw_EA (reset_vector_start EA,(4:ii)) >>
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (56:ii) (63:ii) >>= fun w__2 ->
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (48:ii) (55:ii) >>= fun w__3 ->
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (40:ii) (47:ii) >>= fun w__4 ->
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (32:ii) (39:ii) >>= fun w__5 ->
  MEMw (reset_vector_start EA,(4:ii),reset_vector_start (w__2 ^^ (w__3 ^^ (w__4 ^^ w__5))))

let execute_Ldbrx (RT, RA, RB) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  MEMr (reset_vector_start EA,(8:ii)) >>= fun load_data ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    ((slice load_data (56:ii) (63:ii)) ^^
     ((slice load_data (48:ii) (55:ii)) ^^
      ((slice load_data (40:ii) (47:ii)) ^^
       ((slice load_data (32:ii) (39:ii)) ^^
        ((slice load_data (24:ii) (31:ii)) ^^
         ((slice load_data (16:ii) (23:ii)) ^^
          ((slice load_data (8:ii) (15:ii)) ^^ (slice load_data (0:ii) (7:ii)))))))))

let execute_Stdbrx (RS, RA, RB) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  MEMw_EA (reset_vector_start EA,(8:ii)) >>
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (56:ii) (63:ii) >>= fun w__2 ->
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (48:ii) (55:ii) >>= fun w__3 ->
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (40:ii) (47:ii) >>= fun w__4 ->
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (32:ii) (39:ii) >>= fun w__5 ->
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (24:ii) (31:ii) >>= fun w__6 ->
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (16:ii) (23:ii) >>= fun w__7 ->
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (8:ii) (15:ii) >>= fun w__8 ->
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (0:ii) (7:ii) >>= fun w__9 ->
  MEMw
    (reset_vector_start EA,
     (8:ii),
     reset_vector_start (w__2 ^^ (w__3 ^^ (w__4 ^^ (w__5 ^^ (w__6 ^^ (w__7 ^^ (w__8 ^^ w__9))))))))

let execute_Lmw (RT, RA, D) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  let EA =
    set_vector_start 0
      (add_VVV (reset_vector_start b) (reset_vector_start (exts ((64:ii),reset_vector_start D)))) in
  let size = (minus_IVI (32:ii) (reset_vector_start RT)) * (4:ii) in
  MEMr (reset_vector_start EA,size) >>= fun buffer ->
  let i = (0:ii) in
  (foreachM_inc (unsigned (reset_vector_start RT),(31:ii),(1:ii)) i
    (fun r i ->
     write_reg
       (access GPR r)
       ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                 B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) ^^
        (slice buffer i (i + (31:ii)))) >>
     let i = i + (32:ii) in
     return i)) >>= fun i ->
  return ()

let execute_Stmw (RS, RA, D) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  let EA =
    set_vector_start 0
      (add_VVV (reset_vector_start b) (reset_vector_start (exts ((64:ii),reset_vector_start D)))) in
  let size = (minus_IVI (32:ii) (reset_vector_start RS)) * (4:ii) in
  MEMw_EA (reset_vector_start EA,size) >>
  let buffer = make_indexed_vector [(0,B0);(993,B0)] B0 0 994 true in
  let i = (0:ii) in
  (foreachM_inc (unsigned (reset_vector_start RS),(31:ii),(1:ii)) (i,buffer)
    (fun r (i,buffer) ->
     read_reg_range (access GPR r) (32:ii) (63:ii) >>= fun w__1 ->
     let buffer = update buffer i (i + (31:ii)) w__1 in
     let i = i + (32:ii) in
     return (i,buffer))) >>= fun (i, buffer) ->
  MEMw
    (reset_vector_start EA,
     size,
     reset_vector_start (slice buffer (0:ii) ((size * (8:ii)) - (1:ii))))

let execute_Lswi (RT, RA, NB) =
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let EA = to_vec_inc ((64:ii),(0:ii)) in
     return EA
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun EA ->
  let r = (0:ii) in
  let r = minus_VII (reset_vector_start RT) (1:ii) in
  let size =
    if bitU_to_bool (eq_vec_range (NB, (0:ii)))
    then (32:ii)
    else unsigned (reset_vector_start NB) in
  MEMr (reset_vector_start EA,size) >>= fun membuffer ->
  let j = (0:ii) in
  let i = (32:ii) in
  (foreachM_dec (if bitU_to_bool (eq_vec_range (NB, (0:ii)))
  then (32:ii)
  else unsigned (reset_vector_start NB),(1:ii),(1:ii)) (EA,i,j,r)
    (fun n (EA,i,j,r) ->
     (if bitU_to_bool (eq_range (i, (32:ii)))
      then
        let r = modulo (r + (1:ii)) (32:ii) in
        write_reg (access GPR r) (to_vec_inc ((64:ii),(0:ii))) >>
        return r
      else return r) >>= fun r ->
     write_reg_range (access GPR r) i (i + (7:ii)) (slice membuffer j (j + (7:ii))) >>
     let j = j + (8:ii) in
     let i = i + (8:ii) in
     let i = if bitU_to_bool (eq_range (i, (64:ii))) then (32:ii) else i in
     let EA = set_vector_start 0 (add_VIV (reset_vector_start EA) (1:ii)) in
     return (EA,i,j,r))) >>= fun (EA, i, j, r) ->
  return ()

let execute_Lswx (RT, RA, RB) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  let r = (0:ii) in
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  let r = minus_VII (reset_vector_start RT) (1:ii) in
  let i = (32:ii) in
  read_reg_range XER (57:ii) (63:ii) >>= fun w__2 ->
  let n_top = unsigned (reset_vector_start w__2) in
  recalculate_dependency () >>
  (if bitU_to_bool (eq_range (n_top, (0:ii)))
   then
     write_reg (access GPR (unsigned (reset_vector_start RT))) (to_vec_inc_undef (64:ii)) >>
     return r
   else
     MEMr (reset_vector_start EA,n_top) >>= fun membuffer ->
     let j = (0:ii) in
     let n_r = quot n_top (4:ii) in
     let n_mod = modulo n_top (4:ii) in
     let n_r = if bitU_to_bool (eq_range (n_mod, (0:ii))) then n_r else n_r + (1:ii) in
     (foreachM_dec (n_r,(1:ii),(1:ii)) (j,r)
       (fun n (j,r) ->
        let r = modulo (r + (1:ii)) (32:ii) in
        let temp = to_vec_inc ((64:ii),(0:ii)) in
        let temp =
          if bitU_to_bool (eq_range (n, (1:ii)))
          then
            match toNatural n_mod with
            | (0:nn) ->
               update temp (32:ii) (63:ii) (set_vector_start 32 (slice membuffer j (j + (31:ii))))
            | (1:nn) ->
               update temp (32:ii) (39:ii) (set_vector_start 32 (slice membuffer j (j + (7:ii))))
            | (2:nn) ->
               update temp (32:ii) (47:ii) (set_vector_start 32 (slice membuffer j (j + (15:ii))))
            | (3:nn) ->
               update temp (32:ii) (55:ii) (set_vector_start 32 (slice membuffer j (j + (23:ii))))
            end
          else update temp (32:ii) (63:ii) (set_vector_start 32 (slice membuffer j (j + (31:ii)))) in
        let j = j + (32:ii) in
        write_reg (access GPR r) temp >>
        return (j,r))) >>= fun (j, r) ->
     return r) >>= fun r ->
  return ()

let execute_Stswi (RS, RA, NB) =
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let EA = to_vec_inc ((64:ii),(0:ii)) in
     return EA
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun EA ->
  let r = (0:ii) in
  let r = minus_VII (reset_vector_start RS) (1:ii) in
  let size =
    if bitU_to_bool (eq_vec_range (NB, (0:ii)))
    then (32:ii)
    else unsigned (reset_vector_start NB) in
  MEMw_EA (reset_vector_start EA,size) >>
  let membuffer = make_indexed_vector [(0,B0);(255,B0)] B0 0 256 true in
  let j = (0:ii) in
  let i = (32:ii) in
  (foreachM_dec (if bitU_to_bool (eq_vec_range (NB, (0:ii)))
  then (32:ii)
  else unsigned (reset_vector_start NB),(1:ii),(1:ii)) (i,j,membuffer,r)
    (fun n (i,j,membuffer,r) ->
     let r = if bitU_to_bool (eq_range (i, (32:ii))) then modulo (r + (1:ii)) (32:ii) else r in
     read_reg_range (access GPR r) i (i + (7:ii)) >>= fun w__1 ->
     let membuffer = update membuffer j (j + (7:ii)) w__1 in
     let j = j + (8:ii) in
     let i = i + (8:ii) in
     let i = if bitU_to_bool (eq_range (i, (64:ii))) then (32:ii) else i in
     return (i,j,membuffer,r))) >>= fun (i, j, membuffer, r) ->
  MEMw
    (reset_vector_start EA,
     size,
     reset_vector_start (slice membuffer (0:ii) ((size * (8:ii)) - (1:ii))))

let execute_Stswx (RS, RA, RB) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  let r = (0:ii) in
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  let r = minus_VII (reset_vector_start RS) (1:ii) in
  let i = (32:ii) in
  read_reg_range XER (57:ii) (63:ii) >>= fun w__2 ->
  let n_top = unsigned (reset_vector_start w__2) in
  recalculate_dependency () >>
  MEMw_EA (reset_vector_start EA,n_top) >>
  let membuffer = make_indexed_vector [(0,B0);(511,B0)] B0 0 512 true in
  let j = (0:ii) in
  (foreachM_dec (n_top,(1:ii),(1:ii)) (j,i,membuffer,r)
    (fun n (j,i,membuffer,r) ->
     let r = if bitU_to_bool (eq_range (i, (32:ii))) then modulo (r + (1:ii)) (32:ii) else r in
     read_reg_range (access GPR r) i (i + (7:ii)) >>= fun w__3 ->
     let membuffer = update membuffer j (j + (7:ii)) w__3 in
     let i = i + (8:ii) in
     let j = j + (8:ii) in
     let i = if bitU_to_bool (eq_range (i, (64:ii))) then (32:ii) else i in
     return (j,i,membuffer,r))) >>= fun (j, i, membuffer, r) ->
  if bitU_to_bool (~(eq_range (n_top, (0:ii))))
  then
    MEMw
      (reset_vector_start EA,
       n_top,
       reset_vector_start (slice membuffer (0:ii) ((n_top * (8:ii)) - (1:ii))))
  else return ()

let execute_Addi (RT, RA, SI) =
  if bitU_to_bool (eq_vec_range (RA, (0:ii)))
  then
    write_reg
      (access GPR (unsigned (reset_vector_start RT)))
      (set_vector_start 0 (exts ((64:ii),reset_vector_start SI)))
  else
    read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
    write_reg
      (access GPR (unsigned (reset_vector_start RT)))
      (set_vector_start 0
        (add_VVV
           (reset_vector_start w__0)
           (reset_vector_start (exts ((64:ii),reset_vector_start SI)))))

let execute_Addis (RT, RA, SI) =
  if bitU_to_bool (eq_vec_range (RA, (0:ii)))
  then
    write_reg
      (access GPR (unsigned (reset_vector_start RT)))
      (set_vector_start 0
        (exts
           ((64:ii),
            reset_vector_start (SI ^^
                                (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true)))))
  else
    read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
    write_reg
      (access GPR (unsigned (reset_vector_start RT)))
      (set_vector_start 0
        (add_VVV
           (reset_vector_start w__0)
           (reset_vector_start (exts
                                  ((64:ii),
                                   reset_vector_start (SI ^^
                                                       (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true)))))))

let execute_Add (RT, RA, RB, OE, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let (temp, overflow, _) =
    match (addSO_VVV (reset_vector_start w__0) (reset_vector_start w__1)) with
    | (v0v', v1v', v2v') -> (v0v',v1v',v2v')
    end in
  write_reg (access GPR (unsigned (reset_vector_start RT))) (set_vector_start 0 temp) >>
  (if bitU_to_bool Rc
   then
     read_reg_bitfield XER "SO" >>= fun xer_so ->
     let xer_so = if bitU_to_bool (OE &. overflow) then overflow else xer_so in
     set_overflow_cr0 (reset_vector_start (set_vector_start 0 temp),xer_so)
   else return ()) >>
  if bitU_to_bool OE
  then set_SO_OV overflow
  else return ()

let execute_Subf (RT, RA, RB, OE, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let (t1, o1, _) =
    match (addSO_VVV
             (reset_vector_start (bitwise_not (reset_vector_start w__0)))
             (reset_vector_start w__1)) with
    | (v3v', v4v', v5v') -> (v3v',v4v',v5v')
    end in
  let (t2, o2, _) =
    match (addSO_VBV (reset_vector_start t1) B1) with | (v6v', v7v', v8v') -> (v6v',v7v',v8v') end in
  let temp = set_vector_start 0 t2 in
  let overflow = o1 |. o2 in
  write_reg (access GPR (unsigned (reset_vector_start RT))) temp >>
  (if bitU_to_bool Rc
   then
     read_reg_bitfield XER "SO" >>= fun xer_so ->
     let xer_so = if bitU_to_bool (OE &. overflow) then overflow else xer_so in
     set_overflow_cr0 (reset_vector_start temp,xer_so)
   else return ()) >>
  if bitU_to_bool OE
  then set_SO_OV overflow
  else return ()

let execute_Addic (RT, RA, SI) =
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  let (temp, _, carry) =
    match (addSO_VVV
             (reset_vector_start w__0)
             (reset_vector_start (exts ((64:ii),reset_vector_start SI)))) with
    | (v9v', v10v', v11v') -> (v9v',v10v',v11v')
    end in
  write_reg (access GPR (unsigned (reset_vector_start RT))) (set_vector_start 0 temp) >>
  write_reg_bitfield XER "CA" carry

let execute_AddicDot (RT, RA, SI) =
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  let (temp, overflow, carry) =
    match (addSO_VVV
             (reset_vector_start w__0)
             (reset_vector_start (exts ((64:ii),reset_vector_start SI)))) with
    | (v12v', v13v', v14v') -> (v12v',v13v',v14v')
    end in
  write_reg (access GPR (unsigned (reset_vector_start RT))) (set_vector_start 0 temp) >>
  write_reg_bitfield XER "CA" carry >>
  read_reg_bitfield XER "SO" >>= fun w__1 ->
  set_overflow_cr0 (reset_vector_start (set_vector_start 0 temp),overflow |. w__1)

let execute_Subfic (RT, RA, SI) =
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  let (t1, o1, c1) =
    match (addSO_VVV
             (reset_vector_start (bitwise_not (reset_vector_start w__0)))
             (reset_vector_start (exts ((64:ii),reset_vector_start SI)))) with
    | (v15v', v16v', v17v') -> (v15v',v16v',v17v')
    end in
  let (t2, o2, c2) =
    match (addSO_VBV (reset_vector_start t1) B1) with
    | (v18v', v19v', v20v') -> (v18v',v19v',v20v')
    end in
  let temp = set_vector_start 0 t2 in
  write_reg (access GPR (unsigned (reset_vector_start RT))) temp >>
  write_reg_bitfield XER "CA" (c1 |. c2)

let execute_Addc (RT, RA, RB, OE, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let (temp, overflow, carry) =
    match (addSO_VVV (reset_vector_start w__0) (reset_vector_start w__1)) with
    | (v21v', v22v', v23v') -> (v21v',v22v',v23v')
    end in
  write_reg (access GPR (unsigned (reset_vector_start RT))) (set_vector_start 0 temp) >>
  (if bitU_to_bool Rc
   then
     read_reg_bitfield XER "SO" >>= fun xer_so ->
     let xer_so = if bitU_to_bool (OE &. overflow) then overflow else xer_so in
     set_overflow_cr0 (reset_vector_start (set_vector_start 0 temp),xer_so)
   else return ()) >>
  write_reg_bitfield XER "CA" carry >>
  if bitU_to_bool OE
  then set_SO_OV overflow
  else return ()

let execute_Subfc (RT, RA, RB, OE, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let (t1, o1, c1) =
    match (addSO_VVV
             (reset_vector_start (bitwise_not (reset_vector_start w__0)))
             (reset_vector_start w__1)) with
    | (v24v', v25v', v26v') -> (v24v',v25v',v26v')
    end in
  let (t2, o2, c2) =
    match (addSO_VBV (reset_vector_start t1) B1) with
    | (v27v', v28v', v29v') -> (v27v',v28v',v29v')
    end in
  let temp = set_vector_start 0 t2 in
  let overflow = o1 |. o2 in
  let carry = c1 |. c2 in
  write_reg (access GPR (unsigned (reset_vector_start RT))) temp >>
  (if bitU_to_bool Rc
   then
     read_reg_bitfield XER "SO" >>= fun xer_so ->
     let xer_so = if bitU_to_bool (OE &. overflow) then overflow else xer_so in
     set_overflow_cr0 (reset_vector_start temp,xer_so)
   else return ()) >>
  write_reg_bitfield XER "CA" carry >>
  if bitU_to_bool OE
  then set_SO_OV overflow
  else return ()

let execute_Adde (RT, RA, RB, OE, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let (t1, o1, c1) =
    match (addSO_VVV (reset_vector_start w__0) (reset_vector_start w__1)) with
    | (v30v', v31v', v32v') -> (v30v',v31v',v32v')
    end in
  read_reg_bitfield XER "CA" >>= fun w__2 ->
  let (t2, o2, c2) =
    match (addSO_VBV (reset_vector_start t1) w__2) with
    | (v33v', v34v', v35v') -> (v33v',v34v',v35v')
    end in
  let temp = set_vector_start 0 t2 in
  let overflow = o1 |. o2 in
  let carry = c1 |. c2 in
  write_reg (access GPR (unsigned (reset_vector_start RT))) temp >>
  (if bitU_to_bool Rc
   then
     read_reg_bitfield XER "SO" >>= fun xer_so ->
     let xer_so = if bitU_to_bool (OE &. overflow) then overflow else xer_so in
     set_overflow_cr0 (reset_vector_start temp,xer_so)
   else return ()) >>
  write_reg_bitfield XER "CA" carry >>
  if bitU_to_bool OE
  then set_SO_OV overflow
  else return ()

let execute_Subfe (RT, RA, RB, OE, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let (t1, o1, c1) =
    match (addSO_VVV
             (reset_vector_start (bitwise_not (reset_vector_start w__0)))
             (reset_vector_start w__1)) with
    | (v36v', v37v', v38v') -> (v36v',v37v',v38v')
    end in
  read_reg_bitfield XER "CA" >>= fun w__2 ->
  let (t2, o2, c2) =
    match (addSO_VBV (reset_vector_start t1) w__2) with
    | (v39v', v40v', v41v') -> (v39v',v40v',v41v')
    end in
  let temp = set_vector_start 0 t2 in
  let overflow = o1 |. o2 in
  let carry = c1 |. c2 in
  write_reg (access GPR (unsigned (reset_vector_start RT))) temp >>
  (if bitU_to_bool Rc
   then
     read_reg_bitfield XER "SO" >>= fun xer_so ->
     let xer_so = if bitU_to_bool (OE &. overflow) then overflow else xer_so in
     set_overflow_cr0 (reset_vector_start temp,xer_so)
   else return ()) >>
  write_reg_bitfield XER "CA" carry >>
  if bitU_to_bool OE
  then set_SO_OV overflow
  else return ()

let execute_Addme (RT, RA, OE, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  read_reg_bitfield XER "CA" >>= fun w__1 ->
  let (t1, o1, c1) =
    match (addSO_VBV (reset_vector_start w__0) w__1) with
    | (v42v', v43v', v44v') -> (v42v',v43v',v44v')
    end in
  let (t2, o2, c2) =
    match (addSO_VVV
             (reset_vector_start t1)
             (reset_vector_start (Vector [B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
                                          B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
                                          B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
                                          B1] 0 true))) with
    | (v45v', v46v', v47v') -> (v45v',v46v',v47v')
    end in
  let temp = set_vector_start 0 t2 in
  let overflow = o1 |. o2 in
  let carry = c1 |. c2 in
  write_reg (access GPR (unsigned (reset_vector_start RT))) temp >>
  (if bitU_to_bool Rc
   then
     read_reg_bitfield XER "SO" >>= fun xer_so ->
     let xer_so = if bitU_to_bool (OE &. overflow) then overflow else xer_so in
     set_overflow_cr0 (reset_vector_start temp,xer_so)
   else return ()) >>
  write_reg_bitfield XER "CA" carry >>
  if bitU_to_bool OE
  then set_SO_OV overflow
  else return ()

let execute_Subfme (RT, RA, OE, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  read_reg_bitfield XER "CA" >>= fun w__1 ->
  let (t1, o1, c1) =
    match (addSO_VBV (reset_vector_start (bitwise_not (reset_vector_start w__0))) w__1) with
    | (v48v', v49v', v50v') -> (v48v',v49v',v50v')
    end in
  let (t2, o2, c2) =
    match (addSO_VVV
             (reset_vector_start t1)
             (reset_vector_start (Vector [B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
                                          B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
                                          B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;
                                          B1] 0 true))) with
    | (v51v', v52v', v53v') -> (v51v',v52v',v53v')
    end in
  let temp = set_vector_start 0 t2 in
  let overflow = o1 |. o2 in
  let carry = c1 |. c2 in
  write_reg (access GPR (unsigned (reset_vector_start RT))) temp >>
  (if bitU_to_bool Rc
   then
     read_reg_bitfield XER "SO" >>= fun xer_so ->
     let xer_so = if bitU_to_bool (OE &. overflow) then overflow else xer_so in
     set_overflow_cr0 (reset_vector_start temp,xer_so)
   else return ()) >>
  write_reg_bitfield XER "CA" carry >>
  if bitU_to_bool OE
  then set_SO_OV overflow
  else return ()

let execute_Addze (RT, RA, OE, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  read_reg_bitfield XER "CA" >>= fun w__1 ->
  let (temp, overflow, carry) =
    match (addSO_VBV (reset_vector_start w__0) w__1) with
    | (v54v', v55v', v56v') -> (v54v',v55v',v56v')
    end in
  write_reg (access GPR (unsigned (reset_vector_start RT))) (set_vector_start 0 temp) >>
  (if bitU_to_bool Rc
   then
     read_reg_bitfield XER "SO" >>= fun xer_so ->
     let xer_so = if bitU_to_bool (OE &. overflow) then overflow else xer_so in
     set_overflow_cr0 (reset_vector_start (set_vector_start 0 temp),xer_so)
   else return ()) >>
  write_reg_bitfield XER "CA" carry >>
  if bitU_to_bool OE
  then set_SO_OV overflow
  else return ()

let execute_Subfze (RT, RA, OE, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  read_reg_bitfield XER "CA" >>= fun w__1 ->
  let (temp, overflow, carry) =
    match (addSO_VBV (reset_vector_start (bitwise_not (reset_vector_start w__0))) w__1) with
    | (v57v', v58v', v59v') -> (v57v',v58v',v59v')
    end in
  write_reg (access GPR (unsigned (reset_vector_start RT))) (set_vector_start 0 temp) >>
  (if bitU_to_bool Rc
   then
     read_reg_bitfield XER "SO" >>= fun xer_so ->
     let xer_so = if bitU_to_bool (OE &. overflow) then overflow else xer_so in
     set_overflow_cr0 (reset_vector_start (set_vector_start 0 temp),xer_so)
   else return ()) >>
  write_reg_bitfield XER "CA" carry >>
  if bitU_to_bool OE
  then set_SO_OV overflow
  else return ()

let execute_Neg (RT, RA, OE, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  let (temp, overflow, _) =
    match (addSO_VBV (reset_vector_start (bitwise_not (reset_vector_start w__0))) B1) with
    | (v60v', v61v', v62v') -> (v60v',v61v',v62v')
    end in
  write_reg (access GPR (unsigned (reset_vector_start RT))) (set_vector_start 0 temp) >>
  (if bitU_to_bool Rc
   then
     read_reg_bitfield XER "SO" >>= fun w__1 ->
     set_overflow_cr0 (reset_vector_start (set_vector_start 0 temp),w__1)
   else return ()) >>
  if bitU_to_bool OE
  then set_SO_OV overflow
  else return ()

let execute_Mulli (RT, RA, SI) =
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  let prod =
    set_vector_start 0
      (multS_VVV
         (reset_vector_start w__0)
         (reset_vector_start (exts ((64:ii),reset_vector_start SI)))) in
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    (set_vector_start 0 (slice prod (64:ii) (127:ii)))

let execute_Mullw (RT, RA, RB, OE, Rc) =
  read_reg_range (access GPR (unsigned (reset_vector_start RA))) (32:ii) (63:ii) >>= fun w__0 ->
  read_reg_range (access GPR (unsigned (reset_vector_start RB))) (32:ii) (63:ii) >>= fun w__1 ->
  let (prod, overflow, _) =
    match (multSO_VVV (reset_vector_start w__0) (reset_vector_start w__1)) with
    | (v63v', v64v', v65v') -> (v63v',v64v',v65v')
    end in
  write_reg (access GPR (unsigned (reset_vector_start RT))) (set_vector_start 0 prod) >>
  (if bitU_to_bool Rc
   then
     read_reg_bitfield XER "SO" >>= fun xer_so ->
     let xer_so = if bitU_to_bool (OE &. overflow) then overflow else xer_so in
     set_overflow_cr0 (reset_vector_start (set_vector_start 0 prod),xer_so)
   else return ()) >>
  if bitU_to_bool OE
  then set_SO_OV overflow
  else return ()

let execute_Mulhw (RT, RA, RB, Rc) =
  let prod = to_vec_inc ((64:ii),(0:ii)) in
  let overflow = B0 in
  read_reg_range (access GPR (unsigned (reset_vector_start RA))) (32:ii) (63:ii) >>= fun w__0 ->
  read_reg_range (access GPR (unsigned (reset_vector_start RB))) (32:ii) (63:ii) >>= fun w__1 ->
  let (p, o, _) =
    match (multSO_VVV (reset_vector_start w__0) (reset_vector_start w__1)) with
    | (v66v', v67v', v68v') -> (v66v',v67v',v68v')
    end in
  let prod = set_vector_start 0 p in
  let overflow = o in
  write_reg_range
    (access GPR (unsigned (reset_vector_start RT))) (32:ii)
    (63:ii)
    (set_vector_start 32 (slice prod (0:ii) (31:ii))) >>
  write_reg_range
    (access GPR (unsigned (reset_vector_start RT))) (0:ii)
    (31:ii)
    (to_vec_inc_undef (((31:ii) - (0:ii)) + (1:ii))) >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun xer_so ->
    read_reg mode64bit >>= fun w__2 ->
    if bitU_to_bool (most_significant w__2)
    then write_reg_field CR "CR0" (set_vector_start 32 (Vector [BU;BU;BU;xer_so] 0 true))
    else set_overflow_cr0 (reset_vector_start prod,xer_so)
  else return ()

let execute_Mulhwu (RT, RA, RB, Rc) =
  read_reg_range (access GPR (unsigned (reset_vector_start RA))) (32:ii) (63:ii) >>= fun w__0 ->
  read_reg_range (access GPR (unsigned (reset_vector_start RB))) (32:ii) (63:ii) >>= fun w__1 ->
  let prod = set_vector_start 0 (mult_VVV (reset_vector_start w__0) (reset_vector_start w__1)) in
  write_reg_range
    (access GPR (unsigned (reset_vector_start RT))) (32:ii)
    (63:ii)
    (set_vector_start 32 (slice prod (0:ii) (31:ii))) >>
  write_reg_range
    (access GPR (unsigned (reset_vector_start RT))) (0:ii)
    (31:ii)
    (to_vec_inc_undef (((31:ii) - (0:ii)) + (1:ii))) >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun xer_so ->
    read_reg mode64bit >>= fun w__2 ->
    if bitU_to_bool (most_significant w__2)
    then write_reg_field CR "CR0" (set_vector_start 32 (Vector [BU;BU;BU;xer_so] 0 true))
    else set_overflow_cr0 (reset_vector_start prod,xer_so)
  else return ()

let execute_Divw (RT, RA, RB, OE, Rc) =
  read_reg_range (access GPR (unsigned (reset_vector_start RA))) (32:ii) (63:ii) >>= fun w__0 ->
  let dividend = set_vector_start 0 w__0 in
  read_reg_range (access GPR (unsigned (reset_vector_start RB))) (32:ii) (63:ii) >>= fun w__1 ->
  let divisor = set_vector_start 0 w__1 in
  let divided =
    Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
            B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
            B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
            B0] 0 true in
  let overflow = B0 in
  let (d, o, _) =
    match (quotSO_VVV (reset_vector_start dividend) (reset_vector_start divisor)) with
    | (v69v', v70v', v71v') -> (v69v',v70v',v71v')
    end in
  let divided = update divided (32:ii) (63:ii) (set_vector_start 32 d) in
  let overflow = o in
  write_reg_range
    (access GPR (unsigned (reset_vector_start RT))) (32:ii)
    (63:ii)
    (slice divided (32:ii) (63:ii)) >>
  write_reg_range
    (access GPR (unsigned (reset_vector_start RT))) (0:ii)
    (31:ii)
    (to_vec_inc_undef (((31:ii) - (0:ii)) + (1:ii))) >>
  (if bitU_to_bool Rc
   then
     read_reg_bitfield XER "SO" >>= fun xer_so ->
     let xer_so = if bitU_to_bool (OE &. overflow) then overflow else xer_so in
     read_reg mode64bit >>= fun w__2 ->
     if bitU_to_bool ((most_significant w__2) |. overflow)
     then write_reg_field CR "CR0" (set_vector_start 32 (Vector [BU;BU;BU;xer_so] 0 true))
     else set_overflow_cr0 (reset_vector_start divided,xer_so)
   else return ()) >>
  if bitU_to_bool OE
  then set_SO_OV overflow
  else return ()

let execute_Divwu (RT, RA, RB, OE, Rc) =
  read_reg_range (access GPR (unsigned (reset_vector_start RA))) (32:ii) (63:ii) >>= fun w__0 ->
  let dividend = set_vector_start 0 w__0 in
  read_reg_range (access GPR (unsigned (reset_vector_start RB))) (32:ii) (63:ii) >>= fun w__1 ->
  let divisor = set_vector_start 0 w__1 in
  let divided =
    Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
            B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
            B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
            B0] 0 true in
  let overflow = B0 in
  let (d, o, _) =
    match (quotO_VVV (reset_vector_start dividend) (reset_vector_start divisor)) with
    | (v72v', v73v', v74v') -> (v72v',v73v',v74v')
    end in
  let divided = update divided (32:ii) (63:ii) (set_vector_start 32 d) in
  let overflow = o in
  write_reg_range
    (access GPR (unsigned (reset_vector_start RT))) (32:ii)
    (63:ii)
    (slice divided (32:ii) (63:ii)) >>
  write_reg_range
    (access GPR (unsigned (reset_vector_start RT))) (0:ii)
    (31:ii)
    (to_vec_inc_undef (((31:ii) - (0:ii)) + (1:ii))) >>
  (if bitU_to_bool Rc
   then
     read_reg_bitfield XER "SO" >>= fun xer_so ->
     let xer_so = if bitU_to_bool (OE &. overflow) then overflow else xer_so in
     read_reg mode64bit >>= fun w__2 ->
     if bitU_to_bool ((most_significant w__2) |. overflow)
     then write_reg_field CR "CR0" (set_vector_start 32 (Vector [BU;BU;BU;xer_so] 0 true))
     else set_overflow_cr0 (reset_vector_start divided,xer_so)
   else return ()) >>
  if bitU_to_bool OE
  then set_SO_OV overflow
  else return ()

let execute_Divwe (RT, RA, RB, OE, Rc) =
  read_reg_range (access GPR (unsigned (reset_vector_start RA))) (32:ii) (63:ii) >>= fun w__0 ->
  let dividend =
    w__0 ^^
    (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
             B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) in
  read_reg_range (access GPR (unsigned (reset_vector_start RB))) (32:ii) (63:ii) >>= fun w__1 ->
  let divisor = set_vector_start 0 w__1 in
  let divided =
    Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
            B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
            B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
            B0] 0 true in
  let overflow = B0 in
  let (d, o, _) =
    match (quotSO_VVV (reset_vector_start dividend) (reset_vector_start divisor)) with
    | (v75v', v76v', v77v') -> (v75v',v76v',v77v')
    end in
  let divided = update divided (32:ii) (63:ii) (slice d (32:ii) (63:ii)) in
  let overflow = o in
  write_reg_range
    (access GPR (unsigned (reset_vector_start RT))) (32:ii)
    (63:ii)
    (slice divided (32:ii) (63:ii)) >>
  write_reg_range
    (access GPR (unsigned (reset_vector_start RT))) (0:ii)
    (31:ii)
    (to_vec_inc_undef (((31:ii) - (0:ii)) + (1:ii))) >>
  (if bitU_to_bool Rc
   then
     read_reg_bitfield XER "SO" >>= fun xer_so ->
     let xer_so = if bitU_to_bool (OE &. overflow) then overflow else xer_so in
     read_reg mode64bit >>= fun w__2 ->
     if bitU_to_bool ((most_significant w__2) |. overflow)
     then write_reg_field CR "CR0" (set_vector_start 32 (Vector [BU;BU;BU;xer_so] 0 true))
     else set_overflow_cr0 (reset_vector_start divided,xer_so)
   else return ()) >>
  if bitU_to_bool OE
  then set_SO_OV overflow
  else return ()

let execute_Divweu (RT, RA, RB, OE, Rc) =
  read_reg_range (access GPR (unsigned (reset_vector_start RA))) (32:ii) (63:ii) >>= fun w__0 ->
  let dividend =
    w__0 ^^
    (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
             B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) in
  read_reg_range (access GPR (unsigned (reset_vector_start RB))) (32:ii) (63:ii) >>= fun w__1 ->
  let divisor = set_vector_start 0 w__1 in
  let divided =
    Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
            B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
            B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
            B0] 0 true in
  let overflow = B0 in
  let (d, o, _) =
    match (quotO_VVV (reset_vector_start dividend) (reset_vector_start divisor)) with
    | (v78v', v79v', v80v') -> (v78v',v79v',v80v')
    end in
  let divided = update divided (32:ii) (63:ii) (slice d (32:ii) (63:ii)) in
  let overflow = o in
  write_reg_range
    (access GPR (unsigned (reset_vector_start RT))) (32:ii)
    (63:ii)
    (slice divided (32:ii) (63:ii)) >>
  write_reg_range
    (access GPR (unsigned (reset_vector_start RT))) (0:ii)
    (31:ii)
    (to_vec_inc_undef (((31:ii) - (0:ii)) + (1:ii))) >>
  (if bitU_to_bool Rc
   then
     read_reg_bitfield XER "SO" >>= fun xer_so ->
     let xer_so = if bitU_to_bool (OE &. overflow) then overflow else xer_so in
     read_reg mode64bit >>= fun w__2 ->
     if bitU_to_bool ((most_significant w__2) |. overflow)
     then write_reg_field CR "CR0" (set_vector_start 32 (Vector [BU;BU;BU;xer_so] 0 true))
     else set_overflow_cr0 (reset_vector_start divided,xer_so)
   else return ()) >>
  if bitU_to_bool OE
  then set_SO_OV overflow
  else return ()

let execute_Mulld (RT, RA, RB, OE, Rc) =
  let prod = to_vec_inc ((128:ii),(0:ii)) in
  let overflow = B0 in
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let (p, o, _) =
    match (multSO_VVV (reset_vector_start w__0) (reset_vector_start w__1)) with
    | (v81v', v82v', v83v') -> (v81v',v82v',v83v')
    end in
  let prod = set_vector_start 0 p in
  let overflow = o in
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    (set_vector_start 0 (slice prod (64:ii) (127:ii))) >>
  (if bitU_to_bool Rc
   then
     read_reg_bitfield XER "SO" >>= fun xer_so ->
     let xer_so = if bitU_to_bool (OE &. overflow) then overflow else xer_so in
     set_overflow_cr0 (reset_vector_start (set_vector_start 0 (slice prod (64:ii) (127:ii))),xer_so)
   else return ()) >>
  if bitU_to_bool OE
  then set_SO_OV overflow
  else return ()

let execute_Mulhd (RT, RA, RB, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let prod = set_vector_start 0 (multS_VVV (reset_vector_start w__0) (reset_vector_start w__1)) in
  write_reg (access GPR (unsigned (reset_vector_start RT))) (slice prod (0:ii) (63:ii)) >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__2 ->
    set_overflow_cr0 (reset_vector_start (slice prod (0:ii) (63:ii)),w__2)
  else return ()

let execute_Mulhdu (RT, RA, RB, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let prod = set_vector_start 0 (mult_VVV (reset_vector_start w__0) (reset_vector_start w__1)) in
  write_reg (access GPR (unsigned (reset_vector_start RT))) (slice prod (0:ii) (63:ii)) >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__2 ->
    set_overflow_cr0 (reset_vector_start (slice prod (0:ii) (63:ii)),w__2)
  else return ()

let execute_Divd (RT, RA, RB, OE, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun dividend ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun divisor ->
  let divided =
    Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
            B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
            B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
            B0] 0 true in
  let overflow = B0 in
  let (d, o, _) =
    match (quotSO_VVV (reset_vector_start dividend) (reset_vector_start divisor)) with
    | (v84v', v85v', v86v') -> (v84v',v85v',v86v')
    end in
  let divided = set_vector_start 0 d in
  let overflow = o in
  write_reg (access GPR (unsigned (reset_vector_start RT))) divided >>
  (if bitU_to_bool OE
   then set_SO_OV overflow
   else return ()) >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__0 ->
    set_overflow_cr0 (reset_vector_start divided,overflow |. w__0)
  else return ()

let execute_Divdu (RT, RA, RB, OE, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun dividend ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun divisor ->
  let divided =
    Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
            B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
            B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
            B0] 0 true in
  let overflow = B0 in
  let (d, o, _) =
    match (quotO_VVV (reset_vector_start dividend) (reset_vector_start divisor)) with
    | (v87v', v88v', v89v') -> (v87v',v88v',v89v')
    end in
  let divided = set_vector_start 0 d in
  let overflow = o in
  write_reg (access GPR (unsigned (reset_vector_start RT))) divided >>
  (if bitU_to_bool OE
   then set_SO_OV overflow
   else return ()) >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__0 ->
    set_overflow_cr0 (reset_vector_start divided,overflow |. w__0)
  else return ()

let execute_Divde (RT, RA, RB, OE, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  let dividend =
    w__0 ^^
    (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
             B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
             B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
             B0] 0 true) in
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun divisor ->
  let divided = to_vec_inc ((128:ii),(0:ii)) in
  let overflow = B0 in
  let (d, o, _) =
    match (quotSO_VVV (reset_vector_start dividend) (reset_vector_start divisor)) with
    | (v90v', v91v', v92v') -> (v90v',v91v',v92v')
    end in
  let divided = set_vector_start 0 d in
  let overflow = o in
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    (set_vector_start 0 (slice divided (64:ii) (127:ii))) >>
  (if bitU_to_bool OE
   then set_SO_OV overflow
   else return ()) >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun xer_so ->
    let xer_so = if bitU_to_bool (OE &. overflow) then overflow else xer_so in
    if bitU_to_bool overflow
    then write_reg_field CR "CR0" (set_vector_start 32 (Vector [BU;BU;BU;xer_so] 0 true))
    else
      set_overflow_cr0
        (reset_vector_start (set_vector_start 0 (slice divided (64:ii) (127:ii))),
         xer_so)
  else return ()

let execute_Divdeu (RT, RA, RB, OE, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__0 ->
  let dividend =
    w__0 ^^
    (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
             B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
             B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
             B0] 0 true) in
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun divisor ->
  let divided = to_vec_inc ((128:ii),(0:ii)) in
  let overflow = B0 in
  let (d, o, _) =
    match (quotO_VVV (reset_vector_start dividend) (reset_vector_start divisor)) with
    | (v93v', v94v', v95v') -> (v93v',v94v',v95v')
    end in
  let divided = set_vector_start 0 d in
  let overflow = o in
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    (set_vector_start 0 (slice divided (64:ii) (127:ii))) >>
  (if bitU_to_bool OE
   then set_SO_OV overflow
   else return ()) >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun xer_so ->
    let xer_so = if bitU_to_bool (OE &. overflow) then overflow else xer_so in
    if bitU_to_bool overflow
    then write_reg_field CR "CR0" (set_vector_start 32 (Vector [BU;BU;BU;xer_so] 0 true))
    else
      set_overflow_cr0
        (reset_vector_start (set_vector_start 0 (slice divided (64:ii) (127:ii))),
         xer_so)
  else return ()

let execute_Cmpi (BF, L, RA, SI) =
  let a = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq (match L with | B0 -> (0:ii) | B1 -> (1:ii) end, (0:ii)))
   then
     read_reg_range (access GPR (unsigned (reset_vector_start RA))) (32:ii) (63:ii) >>= fun w__0 ->
     let a = set_vector_start 0 (exts ((64:ii),reset_vector_start w__0)) in
     return a
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun a ->
  let c = make_indexed_vector [] B0 0 3 true in
  let c =
    if bitU_to_bool (lt_vec (a, exts ((64:ii),reset_vector_start SI)))
    then Vector [B1;B0;B0] 0 true
    else
      if bitU_to_bool (gt_vec (a, exts ((64:ii),reset_vector_start SI)))
      then Vector [B0;B1;B0] 0 true
      else Vector [B0;B0;B1] 0 true in
  read_reg_bitfield XER "SO" >>= fun w__2 ->
  write_reg_range
    CR (add_VII (reset_vector_start (mult_IVV (4:ii) (reset_vector_start BF))) (32:ii))
    (add_VII (reset_vector_start (mult_IVV (4:ii) (reset_vector_start BF))) (35:ii))
    (c ^^ (Vector [w__2] 0 true))

let execute_Cmp (BF, L, RA, RB) =
  let a = to_vec_inc ((64:ii),(0:ii)) in
  let b = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq (match L with | B0 -> (0:ii) | B1 -> (1:ii) end, (0:ii)))
   then
     read_reg_range (access GPR (unsigned (reset_vector_start RA))) (32:ii) (63:ii) >>= fun w__0 ->
     let a = set_vector_start 0 (exts ((64:ii),reset_vector_start w__0)) in
     read_reg_range (access GPR (unsigned (reset_vector_start RB))) (32:ii) (63:ii) >>= fun w__1 ->
     let b = set_vector_start 0 (exts ((64:ii),reset_vector_start w__1)) in
     return (a,b)
   else
     read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__2 ->
     let a = w__2 in
     read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__3 ->
     let b = w__3 in
     return (a,b)) >>= fun (a, b) ->
  let c = make_indexed_vector [] B0 0 3 true in
  let c =
    if bitU_to_bool (lt_vec (a, b))
    then Vector [B1;B0;B0] 0 true
    else if bitU_to_bool (gt_vec (a, b)) then Vector [B0;B1;B0] 0 true else Vector [B0;B0;B1] 0 true in
  read_reg_bitfield XER "SO" >>= fun w__4 ->
  write_reg_range
    CR (add_VII (reset_vector_start (mult_IVV (4:ii) (reset_vector_start BF))) (32:ii))
    (add_VII (reset_vector_start (mult_IVV (4:ii) (reset_vector_start BF))) (35:ii))
    (c ^^ (Vector [w__4] 0 true))

let execute_Cmpli (BF, L, RA, UI) =
  let a = to_vec_inc ((64:ii),(0:ii)) in
  let c = to_vec_inc ((3:ii),(0:ii)) in
  (if bitU_to_bool (eq (match L with | B0 -> (0:ii) | B1 -> (1:ii) end, (0:ii)))
   then
     read_reg_range (access GPR (unsigned (reset_vector_start RA))) (32:ii) (63:ii) >>= fun w__0 ->
     let a =
       (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) ^^
       w__0 in
     return a
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun a ->
  let c =
    if bitU_to_bool
         (lt_vec_unsigned
            (a,
            (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0] 0 true) ^^
            UI))
    then Vector [B1;B0;B0] 0 true
    else
      if bitU_to_bool
           (gt_vec_unsigned
              (a,
              (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0] 0 true) ^^
              UI))
      then Vector [B0;B1;B0] 0 true
      else Vector [B0;B0;B1] 0 true in
  read_reg_bitfield XER "SO" >>= fun w__2 ->
  write_reg_range
    CR (add_VII (reset_vector_start (mult_IVV (4:ii) (reset_vector_start BF))) (32:ii))
    (add_VII (reset_vector_start (mult_IVV (4:ii) (reset_vector_start BF))) (35:ii))
    (c ^^ (Vector [w__2] 0 true))

let execute_Cmpl (BF, L, RA, RB) =
  let a = to_vec_inc ((64:ii),(0:ii)) in
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let c = to_vec_inc ((3:ii),(0:ii)) in
  (if bitU_to_bool (eq (match L with | B0 -> (0:ii) | B1 -> (1:ii) end, (0:ii)))
   then
     read_reg_range (access GPR (unsigned (reset_vector_start RA))) (32:ii) (63:ii) >>= fun w__0 ->
     let a =
       (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) ^^
       w__0 in
     read_reg_range (access GPR (unsigned (reset_vector_start RB))) (32:ii) (63:ii) >>= fun w__1 ->
     let b =
       (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) ^^
       w__1 in
     return (a,b)
   else
     read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__2 ->
     let a = w__2 in
     read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__3 ->
     let b = w__3 in
     return (a,b)) >>= fun (a, b) ->
  let c =
    if bitU_to_bool (lt_vec_unsigned (a, b))
    then Vector [B1;B0;B0] 0 true
    else
      if bitU_to_bool (gt_vec_unsigned (a, b))
      then Vector [B0;B1;B0] 0 true
      else Vector [B0;B0;B1] 0 true in
  read_reg_bitfield XER "SO" >>= fun w__4 ->
  write_reg_range
    CR (add_VII (reset_vector_start (mult_IVV (4:ii) (reset_vector_start BF))) (32:ii))
    (add_VII (reset_vector_start (mult_IVV (4:ii) (reset_vector_start BF))) (35:ii))
    (c ^^ (Vector [w__4] 0 true))

let execute_Isel (RT, RA, RB, BC) =
  let a = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let a = to_vec_inc ((64:ii),(0:ii)) in
     return a
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun a ->
  read_reg_bit CR (add_VII (reset_vector_start BC) (32:ii)) >>= fun w__1 ->
  if bitU_to_bool (eq (match w__1 with | B0 -> (0:ii) | B1 -> (1:ii) end, (1:ii)))
  then
    write_reg (access GPR (unsigned (reset_vector_start RT))) a >>
    let discard = access GPR (unsigned (reset_vector_start RB)) in
    return ()
  else
    read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__2 ->
    write_reg (access GPR (unsigned (reset_vector_start RT))) w__2

let execute_Andi (RS, RA, UI) =
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  let temp =
    set_vector_start 0
      (bitwise_and
         (w__0,
         (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                  B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                  B0;B0;B0;B0;B0;B0] 0 true) ^^
         UI)) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  read_reg_bitfield XER "SO" >>= fun w__1 ->
  set_overflow_cr0 (reset_vector_start temp,w__1)

let execute_Andis (RS, RA, UI) =
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  let temp =
    set_vector_start 0
      (bitwise_and
         (w__0,
         (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                  B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) ^^
         (UI ^^ (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true)))) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  read_reg_bitfield XER "SO" >>= fun w__1 ->
  set_overflow_cr0 (reset_vector_start temp,w__1)

let execute_Ori (RS, RA, UI) =
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RA)))
    (set_vector_start 0
      (bitwise_or
         (w__0,
         (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                  B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                  B0;B0;B0;B0;B0;B0] 0 true) ^^
         UI)))

let execute_Oris (RS, RA, UI) =
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RA)))
    (set_vector_start 0
      (bitwise_or
         (w__0,
         (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                  B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) ^^
         (UI ^^ (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true)))))

let execute_Xori (RS, RA, UI) =
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RA)))
    (set_vector_start 0
      (bitwise_xor
         (w__0,
         (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                  B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                  B0;B0;B0;B0;B0;B0] 0 true) ^^
         UI)))

let execute_Xoris (RS, RA, UI) =
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RA)))
    (set_vector_start 0
      (bitwise_xor
         (w__0,
         (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                  B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) ^^
         (UI ^^ (Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true)))))

let execute_And (RS, RA, RB, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let temp = set_vector_start 0 (bitwise_and (w__0, w__1)) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__2 ->
    set_overflow_cr0 (reset_vector_start temp,w__2)
  else return ()

let execute_Xor (RS, RA, RB, Rc) =
  let temp = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec (RS, RB))
   then
     read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
     let temp = w__0 in
     let temp = to_vec_inc ((64:ii),(0:ii)) in
     write_reg (access GPR (unsigned (reset_vector_start RA))) (to_vec_inc ((64:ii),(0:ii))) >>
     return temp
   else
     read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__1 ->
     read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__2 ->
     let temp = set_vector_start 0 (bitwise_xor (w__1, w__2)) in
     write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
     return temp) >>= fun temp ->
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__3 ->
    set_overflow_cr0 (reset_vector_start temp,w__3)
  else return ()

let execute_Nand (RS, RA, RB, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let temp = set_vector_start 0 (bitwise_not (reset_vector_start (bitwise_and (w__0, w__1)))) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__2 ->
    set_overflow_cr0 (reset_vector_start temp,w__2)
  else return ()

let execute_Or (RS, RA, RB, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let temp = set_vector_start 0 (bitwise_or (w__0, w__1)) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__2 ->
    set_overflow_cr0 (reset_vector_start temp,w__2)
  else return ()

let execute_Nor (RS, RA, RB, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let temp = set_vector_start 0 (bitwise_not (reset_vector_start (bitwise_or (w__0, w__1)))) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__2 ->
    set_overflow_cr0 (reset_vector_start temp,w__2)
  else return ()

let execute_Eqv (RS, RA, RB, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let temp = set_vector_start 0 (bitwise_xor (w__0, bitwise_not (reset_vector_start w__1))) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__2 ->
    set_overflow_cr0 (reset_vector_start temp,w__2)
  else return ()

let execute_Andc (RS, RA, RB, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let temp = set_vector_start 0 (bitwise_and (w__0, bitwise_not (reset_vector_start w__1))) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__2 ->
    set_overflow_cr0 (reset_vector_start temp,w__2)
  else return ()

let execute_Orc (RS, RA, RB, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let temp = set_vector_start 0 (bitwise_or (w__0, bitwise_not (reset_vector_start w__1))) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__2 ->
    set_overflow_cr0 (reset_vector_start temp,w__2)
  else return ()

let execute_Extsb (RS, RA, Rc) =
  let temp = to_vec_inc ((64:ii),(0:ii)) in
  read_reg_bit (access GPR (unsigned (reset_vector_start RS))) (56:ii) >>= fun s ->
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (56:ii) (63:ii) >>= fun w__0 ->
  let temp = update temp (56:ii) (63:ii) w__0 in
  write_reg_range
    (access GPR (unsigned (reset_vector_start RA))) (56:ii)
    (63:ii)
    (slice temp (56:ii) (63:ii)) >>
  let temp = update temp (0:ii) (55:ii) (duplicate (s, (56:ii))) in
  write_reg_range
    (access GPR (unsigned (reset_vector_start RA))) (0:ii)
    (55:ii)
    (slice temp (0:ii) (55:ii)) >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__1 ->
    set_overflow_cr0 (reset_vector_start temp,w__1)
  else return ()

let execute_Extsh (RS, RA, Rc) =
  let temp = to_vec_inc ((64:ii),(0:ii)) in
  read_reg_bit (access GPR (unsigned (reset_vector_start RS))) (48:ii) >>= fun s ->
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (48:ii) (63:ii) >>= fun w__0 ->
  let temp = update temp (48:ii) (63:ii) w__0 in
  write_reg_range
    (access GPR (unsigned (reset_vector_start RA))) (48:ii)
    (63:ii)
    (slice temp (48:ii) (63:ii)) >>
  let temp = update temp (0:ii) (47:ii) (duplicate (s, (48:ii))) in
  write_reg_range
    (access GPR (unsigned (reset_vector_start RA))) (0:ii)
    (47:ii)
    (slice temp (0:ii) (47:ii)) >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__1 ->
    set_overflow_cr0 (reset_vector_start temp,w__1)
  else return ()

let execute_Cntlzw (RS, RA, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  let temp = to_vec_inc ((64:ii),countLeadingZeroes (reset_vector_start w__0,(32:ii))) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__1 ->
    set_overflow_cr0 (reset_vector_start temp,w__1)
  else return ()

let execute_Cmpb (RS, RA, RB) =
  (foreachM_inc ((0:ii),(7:ii),(1:ii)) ()
    (fun n _ ->
     read_reg_range (access GPR (unsigned (reset_vector_start RS)))
       ((8:ii) * n) (((8:ii) * n) + (7:ii)) >>= fun w__0 ->
     read_reg_range (access GPR (unsigned (reset_vector_start RB)))
       ((8:ii) * n) (((8:ii) * n) + (7:ii)) >>= fun w__1 ->
     if bitU_to_bool (eq_vec (w__0, w__1))
     then
       write_reg_range
         (access GPR (unsigned (reset_vector_start RA))) ((8:ii) * n)
         (((8:ii) * n) + (7:ii))
         (Vector [B1;B1;B1;B1;B1;B1;B1;B1] 0 true)
     else
       write_reg_range
         (access GPR (unsigned (reset_vector_start RA))) ((8:ii) * n)
         (((8:ii) * n) + (7:ii))
         (to_vec_inc ((8:ii),(0:ii)))))

let execute_Popcntb (RS, RA) =
  (foreachM_inc ((0:ii),(7:ii),(1:ii)) ()
    (fun i _ ->
     let n = (0:ii) in
     (foreachM_inc ((0:ii),(7:ii),(1:ii)) n
       (fun j n ->
        read_reg_bit (access GPR (unsigned (reset_vector_start RS))) ((i * (8:ii)) + j) >>= fun w__0 ->
        let n =
          if bitU_to_bool (eq (match w__0 with | B0 -> (0:ii) | B1 -> (1:ii) end, (1:ii)))
          then n + (1:ii)
          else n in
        return n)) >>= fun n ->
     write_reg_range
       (access GPR (unsigned (reset_vector_start RA))) (i * (8:ii))
       ((i * (8:ii)) + (7:ii))
       (to_vec_inc ((8:ii),n))))

let execute_Popcntw (RS, RA) =
  (foreachM_inc ((0:ii),(1:ii),(1:ii)) ()
    (fun i _ ->
     let n = (0:ii) in
     (foreachM_inc ((0:ii),(31:ii),(1:ii)) n
       (fun j n ->
        read_reg_bit (access GPR (unsigned (reset_vector_start RS))) ((i * (32:ii)) + j) >>= fun w__0 ->
        let n =
          if bitU_to_bool (eq (match w__0 with | B0 -> (0:ii) | B1 -> (1:ii) end, (1:ii)))
          then n + (1:ii)
          else n in
        return n)) >>= fun n ->
     write_reg_range
       (access GPR (unsigned (reset_vector_start RA))) (i * (32:ii))
       ((i * (32:ii)) + (31:ii))
       (to_vec_inc ((32:ii),n))))

let execute_Prtyd (RS, RA) =
  let s = (0:ii) in
  (foreachM_inc ((0:ii),(7:ii),(1:ii)) s
    (fun i s ->
     read_reg_bit (access GPR (unsigned (reset_vector_start RS))) ((i * (8:ii)) + (7:ii)) >>= fun w__0 ->
     let s =
       match ((if bitU_to_bool (is_one s)
               then B1
               else B0) +. w__0) with
       | B0 -> (0:ii)
       | B1 -> (1:ii)
       end in
     return s)) >>= fun s ->
  write_reg
    (access GPR (unsigned (reset_vector_start RA)))
    ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) ^^
     (Vector [if bitU_to_bool (is_one s) then B1 else B0] 0 true))

let execute_Prtyw (RS, RA) =
  let s = (0:ii) in
  let t = (0:ii) in
  (foreachM_inc ((0:ii),(3:ii),(1:ii)) s
    (fun i s ->
     read_reg_bit (access GPR (unsigned (reset_vector_start RS))) ((i * (8:ii)) + (7:ii)) >>= fun w__0 ->
     let s =
       match ((if bitU_to_bool (is_one s)
               then B1
               else B0) +. w__0) with
       | B0 -> (0:ii)
       | B1 -> (1:ii)
       end in
     return s)) >>= fun s ->
  (foreachM_inc ((4:ii),(7:ii),(1:ii)) t
    (fun i t ->
     read_reg_bit (access GPR (unsigned (reset_vector_start RS))) ((i * (8:ii)) + (7:ii)) >>= fun w__1 ->
     let t =
       match ((if bitU_to_bool (is_one t)
               then B1
               else B0) +. w__1) with
       | B0 -> (0:ii)
       | B1 -> (1:ii)
       end in
     return t)) >>= fun t ->
  write_reg_range
    (access GPR (unsigned (reset_vector_start RA))) (0:ii)
    (31:ii)
    ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) ^^
     (Vector [if bitU_to_bool (is_one s) then B1 else B0] 0 true)) >>
  write_reg_range
    (access GPR (unsigned (reset_vector_start RA))) (32:ii)
    (63:ii)
    (set_vector_start 32
      ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) ^^
       (Vector [if bitU_to_bool (is_one t) then B1 else B0] 0 true)))

let execute_Extsw (RS, RA, Rc) =
  read_reg_bit (access GPR (unsigned (reset_vector_start RS))) (32:ii) >>= fun s ->
  let temp = to_vec_inc ((64:ii),(0:ii)) in
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (32:ii) (63:ii) >>= fun w__0 ->
  let temp = update temp (32:ii) (63:ii) w__0 in
  let temp = update temp (0:ii) (31:ii) (duplicate (s, (32:ii))) in
  (if bitU_to_bool Rc
   then
     read_reg_bitfield XER "SO" >>= fun w__1 ->
     set_overflow_cr0 (reset_vector_start temp,w__1)
   else return ()) >>
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp

let execute_Cntlzd (RS, RA, Rc) =
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  let temp = to_vec_inc ((64:ii),countLeadingZeroes (reset_vector_start w__0,(0:ii))) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__1 ->
    set_overflow_cr0 (reset_vector_start temp,w__1)
  else return ()

let execute_Popcntd (RS, RA) =
  let n = (0:ii) in
  (foreachM_inc ((0:ii),(63:ii),(1:ii)) n
    (fun i n ->
     read_reg_bit (access GPR (unsigned (reset_vector_start RS))) i >>= fun w__0 ->
     let n =
       if bitU_to_bool (eq (match w__0 with | B0 -> (0:ii) | B1 -> (1:ii) end, (1:ii)))
       then n + (1:ii)
       else n in
     return n)) >>= fun n ->
  write_reg (access GPR (unsigned (reset_vector_start RA))) (to_vec_inc ((64:ii),n))

let execute_Bpermd (RS, RA, RB) =
  let perm = to_vec_inc ((8:ii),(0:ii)) in
  (foreachM_inc ((0:ii),(7:ii),(1:ii)) perm
    (fun i perm ->
     read_reg_range (access GPR (unsigned (reset_vector_start RS)))
       ((8:ii) * i) (((8:ii) * i) + (7:ii)) >>= fun index ->
     if bitU_to_bool (lt_vec_unsigned (index, to_vec_inc ((8:ii),(64:ii))))
     then
       read_reg_bit (access GPR (unsigned (reset_vector_start RB))) (unsigned
                                                                       (reset_vector_start index)) >>= fun w__0 ->
       let perm = update_pos perm i w__0 in
       return perm
     else
       let perm = update_pos perm i B0 in
       let discard = access GPR (unsigned (reset_vector_start RB)) in
       return perm)) >>= fun perm ->
  write_reg
    (access GPR (unsigned (reset_vector_start RA)))
    ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) ^^
     (slice perm (0:ii) (7:ii)))

let execute_Rlwinm (RS, RA, SH, MB, ME, Rc) =
  let n = SH in
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (32:ii) (63:ii) >>= fun w__0 ->
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (32:ii) (63:ii) >>= fun w__1 ->
  let r = ROTL (reset_vector_start (w__0 ^^ w__1),unsigned (reset_vector_start n)) in
  let m = MASK (add_VII (reset_vector_start MB) (32:ii),add_VII (reset_vector_start ME) (32:ii)) in
  let temp = set_vector_start 0 (bitwise_and (r, m)) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__2 ->
    set_overflow_cr0 (reset_vector_start temp,w__2)
  else return ()

let execute_Rlwnm (RS, RA, RB, MB, ME, Rc) =
  read_reg_range (access GPR (unsigned (reset_vector_start RB))) (59:ii) (63:ii) >>= fun n ->
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (32:ii) (63:ii) >>= fun w__0 ->
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (32:ii) (63:ii) >>= fun w__1 ->
  let r = ROTL (reset_vector_start (w__0 ^^ w__1),unsigned (reset_vector_start n)) in
  let m = MASK (add_VII (reset_vector_start MB) (32:ii),add_VII (reset_vector_start ME) (32:ii)) in
  let temp = set_vector_start 0 (bitwise_and (r, m)) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__2 ->
    set_overflow_cr0 (reset_vector_start temp,w__2)
  else return ()

let execute_Rlwimi (RS, RA, SH, MB, ME, Rc) =
  let n = SH in
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (32:ii) (63:ii) >>= fun w__0 ->
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (32:ii) (63:ii) >>= fun w__1 ->
  let r = ROTL (reset_vector_start (w__0 ^^ w__1),unsigned (reset_vector_start n)) in
  let m = MASK (add_VII (reset_vector_start MB) (32:ii),add_VII (reset_vector_start ME) (32:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__2 ->
  let temp =
    set_vector_start 0
      (bitwise_or (bitwise_and (r, m), bitwise_and (w__2, bitwise_not (reset_vector_start m)))) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__3 ->
    set_overflow_cr0 (reset_vector_start temp,w__3)
  else return ()

let execute_Rldicl (RS, RA, sh, mb, Rc) =
  let n = (Vector [access sh (5:ii)] 0 true) ^^ (slice sh (0:ii) (4:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  let r = ROTL (reset_vector_start w__0,unsigned (reset_vector_start n)) in
  let b = (Vector [access mb (5:ii)] 0 true) ^^ (slice mb (0:ii) (4:ii)) in
  let m = MASK (unsigned (reset_vector_start b),(63:ii)) in
  let temp = set_vector_start 0 (bitwise_and (r, m)) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__1 ->
    set_overflow_cr0 (reset_vector_start temp,w__1)
  else return ()

let execute_Rldicr (RS, RA, sh, me, Rc) =
  let n = (Vector [access sh (5:ii)] 0 true) ^^ (slice sh (0:ii) (4:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  let r = ROTL (reset_vector_start w__0,unsigned (reset_vector_start n)) in
  let e = (Vector [access me (5:ii)] 0 true) ^^ (slice me (0:ii) (4:ii)) in
  let m = MASK ((0:ii),unsigned (reset_vector_start e)) in
  let temp = set_vector_start 0 (bitwise_and (r, m)) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__1 ->
    set_overflow_cr0 (reset_vector_start temp,w__1)
  else return ()

let execute_Rldic (RS, RA, sh, mb, Rc) =
  let n = (Vector [access sh (5:ii)] 0 true) ^^ (slice sh (0:ii) (4:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  let r = ROTL (reset_vector_start w__0,unsigned (reset_vector_start n)) in
  let b = (Vector [access mb (5:ii)] 0 true) ^^ (slice mb (0:ii) (4:ii)) in
  let m =
    MASK
      (unsigned (reset_vector_start b),
       unsigned (reset_vector_start (bitwise_not (reset_vector_start n)))) in
  let temp = set_vector_start 0 (bitwise_and (r, m)) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__1 ->
    set_overflow_cr0 (reset_vector_start temp,w__1)
  else return ()

let execute_Rldcl (RS, RA, RB, mb, Rc) =
  read_reg_range (access GPR (unsigned (reset_vector_start RB))) (58:ii) (63:ii) >>= fun n ->
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  let r = ROTL (reset_vector_start w__0,unsigned (reset_vector_start n)) in
  let b = (Vector [access mb (5:ii)] 0 true) ^^ (slice mb (0:ii) (4:ii)) in
  let m = MASK (unsigned (reset_vector_start b),(63:ii)) in
  let temp = set_vector_start 0 (bitwise_and (r, m)) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__1 ->
    set_overflow_cr0 (reset_vector_start temp,w__1)
  else return ()

let execute_Rldcr (RS, RA, RB, me, Rc) =
  read_reg_range (access GPR (unsigned (reset_vector_start RB))) (58:ii) (63:ii) >>= fun n ->
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  let r = ROTL (reset_vector_start w__0,unsigned (reset_vector_start n)) in
  let e = (Vector [access me (5:ii)] 0 true) ^^ (slice me (0:ii) (4:ii)) in
  let m = MASK ((0:ii),unsigned (reset_vector_start e)) in
  let temp = set_vector_start 0 (bitwise_and (r, m)) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__1 ->
    set_overflow_cr0 (reset_vector_start temp,w__1)
  else return ()

let execute_Rldimi (RS, RA, sh, mb, Rc) =
  let n = (Vector [access sh (5:ii)] 0 true) ^^ (slice sh (0:ii) (4:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  let r = ROTL (reset_vector_start w__0,unsigned (reset_vector_start n)) in
  let b = (Vector [access mb (5:ii)] 0 true) ^^ (slice mb (0:ii) (4:ii)) in
  let m =
    MASK
      (unsigned (reset_vector_start b),
       unsigned (reset_vector_start (bitwise_not (reset_vector_start n)))) in
  read_reg (access GPR (unsigned (reset_vector_start RA))) >>= fun w__1 ->
  let temp =
    set_vector_start 0
      (bitwise_or (bitwise_and (r, m), bitwise_and (w__1, bitwise_not (reset_vector_start m)))) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__2 ->
    set_overflow_cr0 (reset_vector_start temp,w__2)
  else return ()

let execute_Slw (RS, RA, RB, Rc) =
  read_reg_range (access GPR (unsigned (reset_vector_start RB))) (59:ii) (63:ii) >>= fun n ->
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (32:ii) (63:ii) >>= fun w__0 ->
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (32:ii) (63:ii) >>= fun w__1 ->
  let r = ROTL (reset_vector_start (w__0 ^^ w__1),unsigned (reset_vector_start n)) in
  let m = make_indexed_vector [] B0 0 64 true in
  read_reg_bit (access GPR (unsigned (reset_vector_start RB))) (58:ii) >>= fun w__2 ->
  let m =
    if bitU_to_bool (eq (match w__2 with | B0 -> (0:ii) | B1 -> (1:ii) end, (0:ii)))
    then MASK ((32:ii),minus_IVI (63:ii) (reset_vector_start n))
    else
      Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0] 0 true in
  let temp = set_vector_start 0 (bitwise_and (r, m)) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__3 ->
    set_overflow_cr0 (reset_vector_start temp,w__3)
  else return ()

let execute_Srw (RS, RA, RB, Rc) =
  read_reg_range (access GPR (unsigned (reset_vector_start RB))) (59:ii) (63:ii) >>= fun n ->
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (32:ii) (63:ii) >>= fun w__0 ->
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (32:ii) (63:ii) >>= fun w__1 ->
  let r = ROTL (reset_vector_start (w__0 ^^ w__1),minus_IVI (64:ii) (reset_vector_start n)) in
  let m = make_indexed_vector [] B0 0 64 true in
  read_reg_bit (access GPR (unsigned (reset_vector_start RB))) (58:ii) >>= fun w__2 ->
  let m =
    if bitU_to_bool (eq (match w__2 with | B0 -> (0:ii) | B1 -> (1:ii) end, (0:ii)))
    then MASK (add_VII (reset_vector_start n) (32:ii),(63:ii))
    else
      Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0] 0 true in
  let temp = set_vector_start 0 (bitwise_and (r, m)) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__3 ->
    set_overflow_cr0 (reset_vector_start temp,w__3)
  else return ()

let execute_Srawi (RS, RA, SH, Rc) =
  let n = SH in
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (32:ii) (63:ii) >>= fun w__0 ->
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (32:ii) (63:ii) >>= fun w__1 ->
  let r = ROTL (reset_vector_start (w__0 ^^ w__1),minus_IVI (64:ii) (reset_vector_start n)) in
  let m = MASK (add_VII (reset_vector_start n) (32:ii),(63:ii)) in
  read_reg_bit (access GPR (unsigned (reset_vector_start RS))) (32:ii) >>= fun s ->
  let temp =
    set_vector_start 0
      (bitwise_or
         (bitwise_and (r, m),
         bitwise_and (duplicate (s, (64:ii)), bitwise_not (reset_vector_start m)))) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  (if bitU_to_bool Rc
   then
     read_reg_bitfield XER "SO" >>= fun w__2 ->
     set_overflow_cr0 (reset_vector_start temp,w__2)
   else return ()) >>
  write_reg_bitfield
    XER "CA"
    (if bitU_to_bool (gt_vec_unsigned (n, to_vec_inc ((5:ii),(0:ii))))
     then s &. (~(eq_vec_range (bitwise_and (r, bitwise_not (reset_vector_start m)), (0:ii))))
     else B0)

let execute_Sraw (RS, RA, RB, Rc) =
  read_reg_range (access GPR (unsigned (reset_vector_start RB))) (59:ii) (63:ii) >>= fun n ->
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (32:ii) (63:ii) >>= fun w__0 ->
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (32:ii) (63:ii) >>= fun w__1 ->
  let r = ROTL (reset_vector_start (w__0 ^^ w__1),minus_IVI (64:ii) (reset_vector_start n)) in
  let m = make_indexed_vector [] B0 0 64 true in
  read_reg_bit (access GPR (unsigned (reset_vector_start RB))) (58:ii) >>= fun w__2 ->
  let m =
    if bitU_to_bool (eq (match w__2 with | B0 -> (0:ii) | B1 -> (1:ii) end, (0:ii)))
    then MASK (add_VII (reset_vector_start n) (32:ii),(63:ii))
    else
      Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0] 0 true in
  read_reg_bit (access GPR (unsigned (reset_vector_start RS))) (32:ii) >>= fun s ->
  let temp =
    set_vector_start 0
      (bitwise_or
         (bitwise_and (r, m),
         bitwise_and (duplicate (s, (64:ii)), bitwise_not (reset_vector_start m)))) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  (if bitU_to_bool Rc
   then
     read_reg_bitfield XER "SO" >>= fun w__3 ->
     set_overflow_cr0 (reset_vector_start temp,w__3)
   else return ()) >>
  write_reg_bitfield
    XER "CA"
    (if bitU_to_bool (gt_vec_unsigned (n, to_vec_inc ((5:ii),(0:ii))))
     then s &. (~(eq_vec_range (bitwise_and (r, bitwise_not (reset_vector_start m)), (0:ii))))
     else B0)

let execute_Sld (RS, RA, RB, Rc) =
  read_reg_range (access GPR (unsigned (reset_vector_start RB))) (58:ii) (63:ii) >>= fun n ->
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  let r = ROTL (reset_vector_start w__0,unsigned (reset_vector_start n)) in
  let m = make_indexed_vector [] B0 0 64 true in
  read_reg_bit (access GPR (unsigned (reset_vector_start RB))) (57:ii) >>= fun w__1 ->
  let m =
    if bitU_to_bool (eq (match w__1 with | B0 -> (0:ii) | B1 -> (1:ii) end, (0:ii)))
    then MASK ((0:ii),minus_IVI (63:ii) (reset_vector_start n))
    else
      Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0] 0 true in
  let temp = set_vector_start 0 (bitwise_and (r, m)) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__2 ->
    set_overflow_cr0 (reset_vector_start temp,w__2)
  else return ()

let execute_Srd (RS, RA, RB, Rc) =
  read_reg_range (access GPR (unsigned (reset_vector_start RB))) (58:ii) (63:ii) >>= fun n ->
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  let r = ROTL (reset_vector_start w__0,minus_IVI (64:ii) (reset_vector_start n)) in
  let m = make_indexed_vector [] B0 0 64 true in
  read_reg_bit (access GPR (unsigned (reset_vector_start RB))) (57:ii) >>= fun w__1 ->
  let m =
    if bitU_to_bool (eq (match w__1 with | B0 -> (0:ii) | B1 -> (1:ii) end, (0:ii)))
    then MASK (unsigned (reset_vector_start n),(63:ii))
    else
      Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0] 0 true in
  let temp = set_vector_start 0 (bitwise_and (r, m)) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  if bitU_to_bool Rc
  then
    read_reg_bitfield XER "SO" >>= fun w__2 ->
    set_overflow_cr0 (reset_vector_start temp,w__2)
  else return ()

let execute_Sradi (RS, RA, sh, Rc) =
  let n = (Vector [access sh (5:ii)] 0 true) ^^ (slice sh (0:ii) (4:ii)) in
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  let r = ROTL (reset_vector_start w__0,minus_IVI (64:ii) (reset_vector_start n)) in
  let m = MASK (unsigned (reset_vector_start n),(63:ii)) in
  read_reg_bit (access GPR (unsigned (reset_vector_start RS))) (0:ii) >>= fun s ->
  let temp =
    set_vector_start 0
      (bitwise_or
         (bitwise_and (r, m),
         bitwise_and (duplicate (s, (64:ii)), bitwise_not (reset_vector_start m)))) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  (if bitU_to_bool Rc
   then
     read_reg_bitfield XER "SO" >>= fun w__1 ->
     set_overflow_cr0 (reset_vector_start temp,w__1)
   else return ()) >>
  write_reg_bitfield
    XER "CA"
    (if bitU_to_bool (gt_vec_unsigned (n, to_vec_inc ((6:ii),(0:ii))))
     then s &. (~(eq_vec_range (bitwise_and (r, bitwise_not (reset_vector_start m)), (0:ii))))
     else B0)

let execute_Srad (RS, RA, RB, Rc) =
  read_reg_range (access GPR (unsigned (reset_vector_start RB))) (58:ii) (63:ii) >>= fun n ->
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__0 ->
  let r = ROTL (reset_vector_start w__0,minus_IVI (64:ii) (reset_vector_start n)) in
  let m = make_indexed_vector [] B0 0 64 true in
  read_reg_bit (access GPR (unsigned (reset_vector_start RB))) (57:ii) >>= fun w__1 ->
  let m =
    if bitU_to_bool (eq (match w__1 with | B0 -> (0:ii) | B1 -> (1:ii) end, (0:ii)))
    then MASK (unsigned (reset_vector_start n),(63:ii))
    else
      Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0] 0 true in
  read_reg_bit (access GPR (unsigned (reset_vector_start RS))) (0:ii) >>= fun s ->
  let temp =
    set_vector_start 0
      (bitwise_or
         (bitwise_and (r, m),
         bitwise_and (duplicate (s, (64:ii)), bitwise_not (reset_vector_start m)))) in
  write_reg (access GPR (unsigned (reset_vector_start RA))) temp >>
  (if bitU_to_bool Rc
   then
     read_reg_bitfield XER "SO" >>= fun w__2 ->
     set_overflow_cr0 (reset_vector_start temp,w__2)
   else return ()) >>
  write_reg_bitfield
    XER "CA"
    (if bitU_to_bool (gt_vec_unsigned (n, to_vec_inc ((6:ii),(0:ii))))
     then s &. (~(eq_vec_range (bitwise_and (r, bitwise_not (reset_vector_start m)), (0:ii))))
     else B0)

let execute_Cdtbcd (RS, RA) =
  (foreachM_inc ((0:ii),(1:ii),(1:ii)) ()
    (fun i _ ->
     let n = i * (32:ii) in
     write_reg_range
       (access GPR (unsigned (reset_vector_start RA))) (n + (0:ii))
       (n + (7:ii))
       (to_vec_inc ((8:ii),(0:ii))) >>
     read_reg_range (access GPR (unsigned (reset_vector_start RS))) (n + (12:ii)) (n + (21:ii)) >>= fun w__0 ->
     write_reg_range
       (access GPR (unsigned (reset_vector_start RA))) (n + (8:ii))
       (n + (19:ii))
       (DEC_TO_BCD (reset_vector_start (set_vector_start 0 w__0))) >>
     read_reg_range (access GPR (unsigned (reset_vector_start RS))) (n + (22:ii)) (n + (31:ii)) >>= fun w__1 ->
     write_reg_range
       (access GPR (unsigned (reset_vector_start RA))) (n + (20:ii))
       (n + (31:ii))
       (DEC_TO_BCD (reset_vector_start (set_vector_start 0 w__1)))))

let execute_Cbcdtd (RS, RA) =
  (foreachM_inc ((0:ii),(1:ii),(1:ii)) ()
    (fun i _ ->
     let n = i * (32:ii) in
     write_reg_range
       (access GPR (unsigned (reset_vector_start RA))) (n + (0:ii))
       (n + (11:ii))
       (to_vec_inc ((12:ii),(0:ii))) >>
     read_reg_range (access GPR (unsigned (reset_vector_start RS))) (n + (8:ii)) (n + (19:ii)) >>= fun w__0 ->
     write_reg_range
       (access GPR (unsigned (reset_vector_start RA))) (n + (12:ii))
       (n + (21:ii))
       (BCD_TO_DEC (reset_vector_start (set_vector_start 0 w__0))) >>
     read_reg_range (access GPR (unsigned (reset_vector_start RS))) (n + (20:ii)) (n + (31:ii)) >>= fun w__1 ->
     write_reg_range
       (access GPR (unsigned (reset_vector_start RA))) (n + (22:ii))
       (n + (31:ii))
       (BCD_TO_DEC (reset_vector_start (set_vector_start 0 w__1)))))

let execute_Addg6s (RT, RA, RB) =
  let dc = to_vec_inc ((16:ii),(0:ii)) in
  (foreachM_inc ((0:ii),(15:ii),(1:ii)) dc
    (fun i dc ->
     read_reg_range (access GPR (unsigned (reset_vector_start RA))) ((4:ii) * i) (63:ii) >>= fun w__0 ->
     read_reg_range (access GPR (unsigned (reset_vector_start RB))) ((4:ii) * i) (63:ii) >>= fun w__1 ->
     let (v, _, co) =
       match (addO_VVV (reset_vector_start w__0) (reset_vector_start w__1)) with
       | (v96v', v97v', v98v') -> (v96v',v97v',v98v')
       end in
     let dc = update_pos dc i (carry_out (reset_vector_start (set_vector_start 0 v),co)) in
     return dc)) >>= fun dc ->
  let c =
    (duplicate (access dc (0:ii), (4:ii))) ^^
    ((duplicate (access dc (1:ii), (4:ii))) ^^
     ((duplicate (access dc (2:ii), (4:ii))) ^^
      ((duplicate (access dc (3:ii), (4:ii))) ^^
       ((duplicate (access dc (4:ii), (4:ii))) ^^
        ((duplicate (access dc (5:ii), (4:ii))) ^^
         ((duplicate (access dc (6:ii), (4:ii))) ^^
          ((duplicate (access dc (7:ii), (4:ii))) ^^
           ((duplicate (access dc (8:ii), (4:ii))) ^^
            ((duplicate (access dc (9:ii), (4:ii))) ^^
             ((duplicate (access dc (10:ii), (4:ii))) ^^
              ((duplicate (access dc (11:ii), (4:ii))) ^^
               ((duplicate (access dc (12:ii), (4:ii))) ^^
                ((duplicate (access dc (13:ii), (4:ii))) ^^
                 ((duplicate (access dc (14:ii), (4:ii))) ^^ (duplicate (access dc (15:ii), (4:ii))))))))))))))))) in
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    (set_vector_start 0
      (bitwise_and
         (bitwise_not (reset_vector_start c),
         Vector [B0;B1;B1;B0;B0;B1;B1;B0;B0;B1;B1;B0;B0;B1;B1;B0;B0;B1;B1;B0;B0;
                 B1;B1;B0;B0;B1;B1;B0;B0;B1;B1;B0;B0;B1;B1;B0;B0;B1;B1;B0;B0;B1;
                 B1;B0;B0;B1;B1;B0;B0;B1;B1;B0;B0;B1;B1;B0;B0;B1;B1;B0;B0;B1;B1;
                 B0] 0 true)))

let execute_Mtspr (RS, spr) =
  let n = (slice spr (5:ii) (9:ii)) ^^ (slice spr (0:ii) (4:ii)) in
  if bitU_to_bool (eq_vec_range (n, (13:ii)))
  then trap ()
  else
    if bitU_to_bool (eq_vec_range (n, (1:ii)))
    then
      read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun reg ->
      let front = zero_or_undef (reset_vector_start (slice reg (0:ii) (31:ii))) in
      let xer_so = access reg (32:ii) in
      let xer_ov = access reg (33:ii) in
      let xer_ca = access reg (34:ii) in
      let mid = zero_or_undef (reset_vector_start (set_vector_start 0 (slice reg (35:ii) (56:ii)))) in
      let bot = set_vector_start 0 (slice reg (57:ii) (63:ii)) in
      write_reg
        XER
        (front ^^
         ((Vector [xer_so] 0 true) ^^
          ((Vector [xer_ov] 0 true) ^^ ((Vector [xer_ca] 0 true) ^^ (mid ^^ bot)))))
    else
      read_reg (access SPR (unsigned (reset_vector_start n))) >>= fun w__0 ->
      if bitU_to_bool (eq_range (length (reset_vector_start w__0), (64:ii)))
      then
        read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__1 ->
        write_reg (access SPR (unsigned (reset_vector_start n))) w__1
      else
        if bitU_to_bool (eq_vec_range (n, (152:ii)))
        then
          read_reg_range (access GPR (unsigned (reset_vector_start RS))) (32:ii) (63:ii) >>= fun CTRL ->
          return ()
        else return ()

let execute_Mfspr (RT, spr) =
  let n = (slice spr (5:ii) (9:ii)) ^^ (slice spr (0:ii) (4:ii)) in
  read_reg (access SPR (unsigned (reset_vector_start n))) >>= fun w__0 ->
  if bitU_to_bool (eq_range (length (reset_vector_start w__0), (64:ii)))
  then
    read_reg (access SPR (unsigned (reset_vector_start n))) >>= fun w__1 ->
    write_reg (access GPR (unsigned (reset_vector_start RT))) w__1
  else
    read_reg (access SPR (unsigned (reset_vector_start n))) >>= fun w__2 ->
    write_reg
      (access GPR (unsigned (reset_vector_start RT)))
      ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) ^^
       w__2)

let execute_Mtcrf (RS, FXM) =
  let mask =
    (duplicate (access FXM (0:ii), (4:ii))) ^^
    ((duplicate (access FXM (1:ii), (4:ii))) ^^
     ((duplicate (access FXM (2:ii), (4:ii))) ^^
      ((duplicate (access FXM (3:ii), (4:ii))) ^^
       ((duplicate (access FXM (4:ii), (4:ii))) ^^
        ((duplicate (access FXM (5:ii), (4:ii))) ^^
         ((duplicate (access FXM (6:ii), (4:ii))) ^^ (duplicate (access FXM (7:ii), (4:ii))))))))) in
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (32:ii) (63:ii) >>= fun w__0 ->
  read_reg CR >>= fun w__1 ->
  write_reg
    CR
    (set_vector_start 32
      (bitwise_or
         (set_vector_start 0 (bitwise_and (w__0, mask)),
         set_vector_start 0 (bitwise_and (w__1, bitwise_not (reset_vector_start mask))))))

let execute_Mfcr RT =
  read_reg CR >>= fun w__0 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) ^^
     w__0)

let execute_Mtocrf (RS, FXM) =
  let n = (0:ii) in
  let count = (0:ii) in
  let (count, n) =
    (foreach_inc ((0:ii),(7:ii),(1:ii)) (count,n)
      (fun i (count,n) ->
       let (n, count) =
         if bitU_to_bool (eq (match (access FXM i) with | B0 -> (0:ii) | B1 -> (1:ii) end, (1:ii)))
         then
           let n = i in
           let count = count + (1:ii) in
           (n,count)
         else (n,count) in
       (count,n))) in
  if bitU_to_bool (eq_range (count, (1:ii)))
  then
    read_reg_range (access GPR (unsigned (reset_vector_start RS)))
      (((4:ii) * n) + (32:ii)) (((4:ii) * n) + (35:ii)) >>= fun w__0 ->
    write_reg_range CR (((4:ii) * n) + (32:ii)) (((4:ii) * n) + (35:ii)) w__0
  else write_reg CR (to_vec_inc_undef (32:ii))

let execute_Mfocrf (RT, FXM) =
  let n = (0:ii) in
  let count = (0:ii) in
  let (count, n) =
    (foreach_inc ((0:ii),(7:ii),(1:ii)) (count,n)
      (fun i (count,n) ->
       let (n, count) =
         if bitU_to_bool (eq (match (access FXM i) with | B0 -> (0:ii) | B1 -> (1:ii) end, (1:ii)))
         then
           let n = i in
           let count = count + (1:ii) in
           (n,count)
         else (n,count) in
       (count,n))) in
  if bitU_to_bool (eq_range (count, (1:ii)))
  then
    let temp = to_vec_inc_undef (64:ii) in
    read_reg_range CR (((4:ii) * n) + (32:ii)) (((4:ii) * n) + (35:ii)) >>= fun w__0 ->
    let temp = update temp (((4:ii) * n) + (32:ii)) (((4:ii) * n) + (35:ii)) w__0 in
    write_reg (access GPR (unsigned (reset_vector_start RT))) temp
  else write_reg (access GPR (unsigned (reset_vector_start RT))) (to_vec_inc_undef (64:ii))

let execute_Mcrxr BF =
  read_reg_range XER (32:ii) (35:ii) >>= fun w__0 ->
  write_reg_range
    CR (add_VII (reset_vector_start (mult_IVV (4:ii) (reset_vector_start BF))) (32:ii))
    (add_VII (reset_vector_start (mult_IVV (4:ii) (reset_vector_start BF))) (35:ii))
    w__0 >>
  write_reg_range XER (32:ii) (35:ii) (set_vector_start 32 (Vector [B0;B0;B0;B0] 0 true))

let execute_Dlmzb (RS, RA, RB, Rc) = return ()

let execute_Macchw (RT, RA, RB, OE, Rc) = return ()

let execute_Macchws (RT, RA, RB, OE, Rc) = return ()

let execute_Macchwu (RT, RA, RB, OE, Rc) = return ()

let execute_Macchwsu (RT, RA, RB, OE, Rc) = return ()

let execute_Machhw (RT, RA, RB, OE, Rc) = return ()

let execute_Machhws (RT, RA, RB, OE, Rc) = return ()

let execute_Machhwu (RT, RA, RB, OE, Rc) = return ()

let execute_Machhwsu (RT, RA, RB, OE, Rc) = return ()

let execute_Maclhw (RT, RA, RB, OE, Rc) = return ()

let execute_Maclhws (RT, RA, RB, OE, Rc) = return ()

let execute_Maclhwu (RT, RA, RB, OE, Rc) = return ()

let execute_Maclhwsu (RT, RA, RB, OE, Rc) = return ()

let execute_Mulchw (RT, RA, RB, Rc) = return ()

let execute_Mulchwu (RT, RA, RB, Rc) = return ()

let execute_Mulhhw (RT, RA, RB, Rc) = return ()

let execute_Mulhhwu (RT, RA, RB, Rc) = return ()

let execute_Mullhw (RT, RA, RB, Rc) = return ()

let execute_Mullhwu (RT, RA, RB, Rc) = return ()

let execute_Nmacchw (RT, RA, RB, OE, Rc) = return ()

let execute_Nmacchws (RT, RA, RB, OE, Rc) = return ()

let execute_Nmachhw (RT, RA, RB, OE, Rc) = return ()

let execute_Nmachhws (RT, RA, RB, OE, Rc) = return ()

let execute_Nmaclhw (RT, RA, RB, OE, Rc) = return ()

let execute_Nmaclhws (RT, RA, RB, OE, Rc) = return ()

let execute_Icbi (RA, RB) = return ()

let execute_Icbt (CT, RA, RB) = return ()

let execute_Dcba (RA, RB) = return ()

let execute_Dcbt (TH, RA, RB) = return ()

let execute_Dcbtst (TH, RA, RB) = return ()

let execute_Dcbz (RA, RB) = return ()

let execute_Dcbst (RA, RB) = return ()

let execute_Dcbf (L, RA, RB) = return ()

let execute_Isync () = I_Sync ()

let execute_Lbarx (RT, RA, RB, EH) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  MEMr_reserve (reset_vector_start EA,(1:ii)) >>= fun w__2 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) ^^
     w__2)

let execute_Lharx (RT, RA, RB, EH) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  MEMr_reserve (reset_vector_start EA,(2:ii)) >>= fun w__2 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0] 0 true) ^^
     w__2)

let execute_Lwarx (RT, RA, RB, EH) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  MEMr_reserve (reset_vector_start EA,(4:ii)) >>= fun w__2 ->
  write_reg
    (access GPR (unsigned (reset_vector_start RT)))
    ((Vector [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0] 0 true) ^^
     w__2)

let execute_Stbcx (RS, RA, RB) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  MEMw_EA_cond (reset_vector_start EA,(1:ii)) >>
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (56:ii) (63:ii) >>= fun w__2 ->
  MEMw_conditional (reset_vector_start EA,(1:ii),reset_vector_start (set_vector_start 0 w__2)) >>= fun status ->
  read_reg_bitfield XER "SO" >>= fun w__3 ->
  let CR0 = (Vector [B0;B0] 0 true) ^^ ((Vector [status] 0 true) ^^ (Vector [w__3] 0 true)) in
  return ()

let execute_Sthcx (RS, RA, RB) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  MEMw_EA_cond (reset_vector_start EA,(2:ii)) >>
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (48:ii) (63:ii) >>= fun w__2 ->
  MEMw_conditional (reset_vector_start EA,(2:ii),reset_vector_start (set_vector_start 0 w__2)) >>= fun status ->
  read_reg_bitfield XER "SO" >>= fun w__3 ->
  let CR0 = (Vector [B0;B0] 0 true) ^^ ((Vector [status] 0 true) ^^ (Vector [w__3] 0 true)) in
  return ()

let execute_Stwcx (RS, RA, RB) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  MEMw_EA_cond (reset_vector_start EA,(4:ii)) >>
  read_reg_range (access GPR (unsigned (reset_vector_start RS))) (32:ii) (63:ii) >>= fun w__2 ->
  MEMw_conditional (reset_vector_start EA,(4:ii),reset_vector_start (set_vector_start 0 w__2)) >>= fun status ->
  read_reg_bitfield XER "SO" >>= fun w__3 ->
  let CR0 = (Vector [B0;B0] 0 true) ^^ ((Vector [status] 0 true) ^^ (Vector [w__3] 0 true)) in
  return ()

let execute_Ldarx (RT, RA, RB, EH) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  MEMr_reserve (reset_vector_start EA,(8:ii)) >>= fun w__2 ->
  write_reg (access GPR (unsigned (reset_vector_start RT))) w__2

let execute_Stdcx (RS, RA, RB) =
  let b = to_vec_inc ((64:ii),(0:ii)) in
  let EA = to_vec_inc ((64:ii),(0:ii)) in
  (if bitU_to_bool (eq_vec_range (RA, (0:ii)))
   then
     let b = to_vec_inc ((64:ii),(0:ii)) in
     return b
   else read_reg (access GPR (unsigned (reset_vector_start RA)))) >>= fun b ->
  read_reg (access GPR (unsigned (reset_vector_start RB))) >>= fun w__1 ->
  let EA = set_vector_start 0 (add_VVV (reset_vector_start b) (reset_vector_start w__1)) in
  MEMw_EA_cond (reset_vector_start EA,(8:ii)) >>
  read_reg (access GPR (unsigned (reset_vector_start RS))) >>= fun w__2 ->
  MEMw_conditional (reset_vector_start EA,(8:ii),reset_vector_start w__2) >>= fun status ->
  read_reg_bitfield XER "SO" >>= fun w__3 ->
  let CR0 = (Vector [B0;B0] 0 true) ^^ ((Vector [status] 0 true) ^^ (Vector [w__3] 0 true)) in
  return ()

let execute_Sync L =
  match L with | Vector [B0;B0] _ _ -> H_Sync () | Vector [B0;B1] _ _ -> LW_Sync () end

let execute_Eieio () = EIEIO_Sync ()

let execute_Wait WC = return ()

let execute = function
  
  | B (LI,AA,LK) -> execute_B (LI,AA,LK)
  | Bc (BO,BI,BD,AA,LK) -> execute_Bc (BO,BI,BD,AA,LK)
  | Bclr (BO,BI,BH,LK) -> execute_Bclr (BO,BI,BH,LK)
  | Bcctr (BO,BI,BH,LK) -> execute_Bcctr (BO,BI,BH,LK)
  | Crand (BT,BA,BB) -> execute_Crand (BT,BA,BB)
  | Crnand (BT,BA,BB) -> execute_Crnand (BT,BA,BB)
  | Cror (BT,BA,BB) -> execute_Cror (BT,BA,BB)
  | Crxor (BT,BA,BB) -> execute_Crxor (BT,BA,BB)
  | Crnor (BT,BA,BB) -> execute_Crnor (BT,BA,BB)
  | Creqv (BT,BA,BB) -> execute_Creqv (BT,BA,BB)
  | Crandc (BT,BA,BB) -> execute_Crandc (BT,BA,BB)
  | Crorc (BT,BA,BB) -> execute_Crorc (BT,BA,BB)
  | Mcrf (BF,BFA) -> execute_Mcrf (BF,BFA)
  | Sc (LEV) -> execute_Sc (LEV)
  | Scv (LEV) -> execute_Scv (LEV)
  | Lbz (RT,RA,D) -> execute_Lbz (RT,RA,D)
  | Lbzx (RT,RA,RB) -> execute_Lbzx (RT,RA,RB)
  | Lbzu (RT,RA,D) -> execute_Lbzu (RT,RA,D)
  | Lbzux (RT,RA,RB) -> execute_Lbzux (RT,RA,RB)
  | Lhz (RT,RA,D) -> execute_Lhz (RT,RA,D)
  | Lhzx (RT,RA,RB) -> execute_Lhzx (RT,RA,RB)
  | Lhzu (RT,RA,D) -> execute_Lhzu (RT,RA,D)
  | Lhzux (RT,RA,RB) -> execute_Lhzux (RT,RA,RB)
  | Lha (RT,RA,D) -> execute_Lha (RT,RA,D)
  | Lhax (RT,RA,RB) -> execute_Lhax (RT,RA,RB)
  | Lhau (RT,RA,D) -> execute_Lhau (RT,RA,D)
  | Lhaux (RT,RA,RB) -> execute_Lhaux (RT,RA,RB)
  | Lwz (RT,RA,D) -> execute_Lwz (RT,RA,D)
  | Lwzx (RT,RA,RB) -> execute_Lwzx (RT,RA,RB)
  | Lwzu (RT,RA,D) -> execute_Lwzu (RT,RA,D)
  | Lwzux (RT,RA,RB) -> execute_Lwzux (RT,RA,RB)
  | Lwa (RT,RA,DS) -> execute_Lwa (RT,RA,DS)
  | Lwax (RT,RA,RB) -> execute_Lwax (RT,RA,RB)
  | Lwaux (RT,RA,RB) -> execute_Lwaux (RT,RA,RB)
  | Ld (RT,RA,DS) -> execute_Ld (RT,RA,DS)
  | Ldx (RT,RA,RB) -> execute_Ldx (RT,RA,RB)
  | Ldu (RT,RA,DS) -> execute_Ldu (RT,RA,DS)
  | Ldux (RT,RA,RB) -> execute_Ldux (RT,RA,RB)
  | Stb (RS,RA,D) -> execute_Stb (RS,RA,D)
  | Stbx (RS,RA,RB) -> execute_Stbx (RS,RA,RB)
  | Stbu (RS,RA,D) -> execute_Stbu (RS,RA,D)
  | Stbux (RS,RA,RB) -> execute_Stbux (RS,RA,RB)
  | Sth (RS,RA,D) -> execute_Sth (RS,RA,D)
  | Sthx (RS,RA,RB) -> execute_Sthx (RS,RA,RB)
  | Sthu (RS,RA,D) -> execute_Sthu (RS,RA,D)
  | Sthux (RS,RA,RB) -> execute_Sthux (RS,RA,RB)
  | Stw (RS,RA,D) -> execute_Stw (RS,RA,D)
  | Stwx (RS,RA,RB) -> execute_Stwx (RS,RA,RB)
  | Stwu (RS,RA,D) -> execute_Stwu (RS,RA,D)
  | Stwux (RS,RA,RB) -> execute_Stwux (RS,RA,RB)
  | Std (RS,RA,DS) -> execute_Std (RS,RA,DS)
  | Stdx (RS,RA,RB) -> execute_Stdx (RS,RA,RB)
  | Stdu (RS,RA,DS) -> execute_Stdu (RS,RA,DS)
  | Stdux (RS,RA,RB) -> execute_Stdux (RS,RA,RB)
  | Lhbrx (RT,RA,RB) -> execute_Lhbrx (RT,RA,RB)
  | Sthbrx (RS,RA,RB) -> execute_Sthbrx (RS,RA,RB)
  | Lwbrx (RT,RA,RB) -> execute_Lwbrx (RT,RA,RB)
  | Stwbrx (RS,RA,RB) -> execute_Stwbrx (RS,RA,RB)
  | Ldbrx (RT,RA,RB) -> execute_Ldbrx (RT,RA,RB)
  | Stdbrx (RS,RA,RB) -> execute_Stdbrx (RS,RA,RB)
  | Lmw (RT,RA,D) -> execute_Lmw (RT,RA,D)
  | Stmw (RS,RA,D) -> execute_Stmw (RS,RA,D)
  | Lswi (RT,RA,NB) -> execute_Lswi (RT,RA,NB)
  | Lswx (RT,RA,RB) -> execute_Lswx (RT,RA,RB)
  | Stswi (RS,RA,NB) -> execute_Stswi (RS,RA,NB)
  | Stswx (RS,RA,RB) -> execute_Stswx (RS,RA,RB)
  | Addi (RT,RA,SI) -> execute_Addi (RT,RA,SI)
  | Addis (RT,RA,SI) -> execute_Addis (RT,RA,SI)
  | Add (RT,RA,RB,OE,Rc) -> execute_Add (RT,RA,RB,OE,Rc)
  | Subf (RT,RA,RB,OE,Rc) -> execute_Subf (RT,RA,RB,OE,Rc)
  | Addic (RT,RA,SI) -> execute_Addic (RT,RA,SI)
  | AddicDot (RT,RA,SI) -> execute_AddicDot (RT,RA,SI)
  | Subfic (RT,RA,SI) -> execute_Subfic (RT,RA,SI)
  | Addc (RT,RA,RB,OE,Rc) -> execute_Addc (RT,RA,RB,OE,Rc)
  | Subfc (RT,RA,RB,OE,Rc) -> execute_Subfc (RT,RA,RB,OE,Rc)
  | Adde (RT,RA,RB,OE,Rc) -> execute_Adde (RT,RA,RB,OE,Rc)
  | Subfe (RT,RA,RB,OE,Rc) -> execute_Subfe (RT,RA,RB,OE,Rc)
  | Addme (RT,RA,OE,Rc) -> execute_Addme (RT,RA,OE,Rc)
  | Subfme (RT,RA,OE,Rc) -> execute_Subfme (RT,RA,OE,Rc)
  | Addze (RT,RA,OE,Rc) -> execute_Addze (RT,RA,OE,Rc)
  | Subfze (RT,RA,OE,Rc) -> execute_Subfze (RT,RA,OE,Rc)
  | Neg (RT,RA,OE,Rc) -> execute_Neg (RT,RA,OE,Rc)
  | Mulli (RT,RA,SI) -> execute_Mulli (RT,RA,SI)
  | Mullw (RT,RA,RB,OE,Rc) -> execute_Mullw (RT,RA,RB,OE,Rc)
  | Mulhw (RT,RA,RB,Rc) -> execute_Mulhw (RT,RA,RB,Rc)
  | Mulhwu (RT,RA,RB,Rc) -> execute_Mulhwu (RT,RA,RB,Rc)
  | Divw (RT,RA,RB,OE,Rc) -> execute_Divw (RT,RA,RB,OE,Rc)
  | Divwu (RT,RA,RB,OE,Rc) -> execute_Divwu (RT,RA,RB,OE,Rc)
  | Divwe (RT,RA,RB,OE,Rc) -> execute_Divwe (RT,RA,RB,OE,Rc)
  | Divweu (RT,RA,RB,OE,Rc) -> execute_Divweu (RT,RA,RB,OE,Rc)
  | Mulld (RT,RA,RB,OE,Rc) -> execute_Mulld (RT,RA,RB,OE,Rc)
  | Mulhd (RT,RA,RB,Rc) -> execute_Mulhd (RT,RA,RB,Rc)
  | Mulhdu (RT,RA,RB,Rc) -> execute_Mulhdu (RT,RA,RB,Rc)
  | Divd (RT,RA,RB,OE,Rc) -> execute_Divd (RT,RA,RB,OE,Rc)
  | Divdu (RT,RA,RB,OE,Rc) -> execute_Divdu (RT,RA,RB,OE,Rc)
  | Divde (RT,RA,RB,OE,Rc) -> execute_Divde (RT,RA,RB,OE,Rc)
  | Divdeu (RT,RA,RB,OE,Rc) -> execute_Divdeu (RT,RA,RB,OE,Rc)
  | Cmpi (BF,L,RA,SI) -> execute_Cmpi (BF,L,RA,SI)
  | Cmp (BF,L,RA,RB) -> execute_Cmp (BF,L,RA,RB)
  | Cmpli (BF,L,RA,UI) -> execute_Cmpli (BF,L,RA,UI)
  | Cmpl (BF,L,RA,RB) -> execute_Cmpl (BF,L,RA,RB)
  | Isel (RT,RA,RB,BC) -> execute_Isel (RT,RA,RB,BC)
  | Andi (RS,RA,UI) -> execute_Andi (RS,RA,UI)
  | Andis (RS,RA,UI) -> execute_Andis (RS,RA,UI)
  | Ori (RS,RA,UI) -> execute_Ori (RS,RA,UI)
  | Oris (RS,RA,UI) -> execute_Oris (RS,RA,UI)
  | Xori (RS,RA,UI) -> execute_Xori (RS,RA,UI)
  | Xoris (RS,RA,UI) -> execute_Xoris (RS,RA,UI)
  | And (RS,RA,RB,Rc) -> execute_And (RS,RA,RB,Rc)
  | Xor (RS,RA,RB,Rc) -> execute_Xor (RS,RA,RB,Rc)
  | Nand (RS,RA,RB,Rc) -> execute_Nand (RS,RA,RB,Rc)
  | Or (RS,RA,RB,Rc) -> execute_Or (RS,RA,RB,Rc)
  | Nor (RS,RA,RB,Rc) -> execute_Nor (RS,RA,RB,Rc)
  | Eqv (RS,RA,RB,Rc) -> execute_Eqv (RS,RA,RB,Rc)
  | Andc (RS,RA,RB,Rc) -> execute_Andc (RS,RA,RB,Rc)
  | Orc (RS,RA,RB,Rc) -> execute_Orc (RS,RA,RB,Rc)
  | Extsb (RS,RA,Rc) -> execute_Extsb (RS,RA,Rc)
  | Extsh (RS,RA,Rc) -> execute_Extsh (RS,RA,Rc)
  | Cntlzw (RS,RA,Rc) -> execute_Cntlzw (RS,RA,Rc)
  | Cmpb (RS,RA,RB) -> execute_Cmpb (RS,RA,RB)
  | Popcntb (RS,RA) -> execute_Popcntb (RS,RA)
  | Popcntw (RS,RA) -> execute_Popcntw (RS,RA)
  | Prtyd (RS,RA) -> execute_Prtyd (RS,RA)
  | Prtyw (RS,RA) -> execute_Prtyw (RS,RA)
  | Extsw (RS,RA,Rc) -> execute_Extsw (RS,RA,Rc)
  | Cntlzd (RS,RA,Rc) -> execute_Cntlzd (RS,RA,Rc)
  | Popcntd (RS,RA) -> execute_Popcntd (RS,RA)
  | Bpermd (RS,RA,RB) -> execute_Bpermd (RS,RA,RB)
  | Rlwinm (RS,RA,SH,MB,ME,Rc) -> execute_Rlwinm (RS,RA,SH,MB,ME,Rc)
  | Rlwnm (RS,RA,RB,MB,ME,Rc) -> execute_Rlwnm (RS,RA,RB,MB,ME,Rc)
  | Rlwimi (RS,RA,SH,MB,ME,Rc) -> execute_Rlwimi (RS,RA,SH,MB,ME,Rc)
  | Rldicl (RS,RA,sh,mb,Rc) -> execute_Rldicl (RS,RA,sh,mb,Rc)
  | Rldicr (RS,RA,sh,me,Rc) -> execute_Rldicr (RS,RA,sh,me,Rc)
  | Rldic (RS,RA,sh,mb,Rc) -> execute_Rldic (RS,RA,sh,mb,Rc)
  | Rldcl (RS,RA,RB,mb,Rc) -> execute_Rldcl (RS,RA,RB,mb,Rc)
  | Rldcr (RS,RA,RB,me,Rc) -> execute_Rldcr (RS,RA,RB,me,Rc)
  | Rldimi (RS,RA,sh,mb,Rc) -> execute_Rldimi (RS,RA,sh,mb,Rc)
  | Slw (RS,RA,RB,Rc) -> execute_Slw (RS,RA,RB,Rc)
  | Srw (RS,RA,RB,Rc) -> execute_Srw (RS,RA,RB,Rc)
  | Srawi (RS,RA,SH,Rc) -> execute_Srawi (RS,RA,SH,Rc)
  | Sraw (RS,RA,RB,Rc) -> execute_Sraw (RS,RA,RB,Rc)
  | Sld (RS,RA,RB,Rc) -> execute_Sld (RS,RA,RB,Rc)
  | Srd (RS,RA,RB,Rc) -> execute_Srd (RS,RA,RB,Rc)
  | Sradi (RS,RA,sh,Rc) -> execute_Sradi (RS,RA,sh,Rc)
  | Srad (RS,RA,RB,Rc) -> execute_Srad (RS,RA,RB,Rc)
  | Cdtbcd (RS,RA) -> execute_Cdtbcd (RS,RA)
  | Cbcdtd (RS,RA) -> execute_Cbcdtd (RS,RA)
  | Addg6s (RT,RA,RB) -> execute_Addg6s (RT,RA,RB)
  | Mtspr (RS,spr) -> execute_Mtspr (RS,spr)
  | Mfspr (RT,spr) -> execute_Mfspr (RT,spr)
  | Mtcrf (RS,FXM) -> execute_Mtcrf (RS,FXM)
  | Mfcr (RT) -> execute_Mfcr (RT)
  | Mtocrf (RS,FXM) -> execute_Mtocrf (RS,FXM)
  | Mfocrf (RT,FXM) -> execute_Mfocrf (RT,FXM)
  | Mcrxr (BF) -> execute_Mcrxr (BF)
  | Dlmzb (RS,RA,RB,Rc) -> execute_Dlmzb (RS,RA,RB,Rc)
  | Macchw (RT,RA,RB,OE,Rc) -> execute_Macchw (RT,RA,RB,OE,Rc)
  | Macchws (RT,RA,RB,OE,Rc) -> execute_Macchws (RT,RA,RB,OE,Rc)
  | Macchwu (RT,RA,RB,OE,Rc) -> execute_Macchwu (RT,RA,RB,OE,Rc)
  | Macchwsu (RT,RA,RB,OE,Rc) -> execute_Macchwsu (RT,RA,RB,OE,Rc)
  | Machhw (RT,RA,RB,OE,Rc) -> execute_Machhw (RT,RA,RB,OE,Rc)
  | Machhws (RT,RA,RB,OE,Rc) -> execute_Machhws (RT,RA,RB,OE,Rc)
  | Machhwu (RT,RA,RB,OE,Rc) -> execute_Machhwu (RT,RA,RB,OE,Rc)
  | Machhwsu (RT,RA,RB,OE,Rc) -> execute_Machhwsu (RT,RA,RB,OE,Rc)
  | Maclhw (RT,RA,RB,OE,Rc) -> execute_Maclhw (RT,RA,RB,OE,Rc)
  | Maclhws (RT,RA,RB,OE,Rc) -> execute_Maclhws (RT,RA,RB,OE,Rc)
  | Maclhwu (RT,RA,RB,OE,Rc) -> execute_Maclhwu (RT,RA,RB,OE,Rc)
  | Maclhwsu (RT,RA,RB,OE,Rc) -> execute_Maclhwsu (RT,RA,RB,OE,Rc)
  | Mulchw (RT,RA,RB,Rc) -> execute_Mulchw (RT,RA,RB,Rc)
  | Mulchwu (RT,RA,RB,Rc) -> execute_Mulchwu (RT,RA,RB,Rc)
  | Mulhhw (RT,RA,RB,Rc) -> execute_Mulhhw (RT,RA,RB,Rc)
  | Mulhhwu (RT,RA,RB,Rc) -> execute_Mulhhwu (RT,RA,RB,Rc)
  | Mullhw (RT,RA,RB,Rc) -> execute_Mullhw (RT,RA,RB,Rc)
  | Mullhwu (RT,RA,RB,Rc) -> execute_Mullhwu (RT,RA,RB,Rc)
  | Nmacchw (RT,RA,RB,OE,Rc) -> execute_Nmacchw (RT,RA,RB,OE,Rc)
  | Nmacchws (RT,RA,RB,OE,Rc) -> execute_Nmacchws (RT,RA,RB,OE,Rc)
  | Nmachhw (RT,RA,RB,OE,Rc) -> execute_Nmachhw (RT,RA,RB,OE,Rc)
  | Nmachhws (RT,RA,RB,OE,Rc) -> execute_Nmachhws (RT,RA,RB,OE,Rc)
  | Nmaclhw (RT,RA,RB,OE,Rc) -> execute_Nmaclhw (RT,RA,RB,OE,Rc)
  | Nmaclhws (RT,RA,RB,OE,Rc) -> execute_Nmaclhws (RT,RA,RB,OE,Rc)
  | Icbi (RA,RB) -> execute_Icbi (RA,RB)
  | Icbt (CT,RA,RB) -> execute_Icbt (CT,RA,RB)
  | Dcba (RA,RB) -> execute_Dcba (RA,RB)
  | Dcbt (TH,RA,RB) -> execute_Dcbt (TH,RA,RB)
  | Dcbtst (TH,RA,RB) -> execute_Dcbtst (TH,RA,RB)
  | Dcbz (RA,RB) -> execute_Dcbz (RA,RB)
  | Dcbst (RA,RB) -> execute_Dcbst (RA,RB)
  | Dcbf (L,RA,RB) -> execute_Dcbf (L,RA,RB)
  | Isync -> execute_Isync ()
  | Lbarx (RT,RA,RB,EH) -> execute_Lbarx (RT,RA,RB,EH)
  | Lharx (RT,RA,RB,EH) -> execute_Lharx (RT,RA,RB,EH)
  | Lwarx (RT,RA,RB,EH) -> execute_Lwarx (RT,RA,RB,EH)
  | Stbcx (RS,RA,RB) -> execute_Stbcx (RS,RA,RB)
  | Sthcx (RS,RA,RB) -> execute_Sthcx (RS,RA,RB)
  | Stwcx (RS,RA,RB) -> execute_Stwcx (RS,RA,RB)
  | Ldarx (RT,RA,RB,EH) -> execute_Ldarx (RT,RA,RB,EH)
  | Stdcx (RS,RA,RB) -> execute_Stdcx (RS,RA,RB)
  | Sync (L) -> execute_Sync (L)
  | Eieio -> execute_Eieio ()
  | Wait (WC) -> execute_Wait (WC)
  end

let initial_analysis instr =
  let iR = [] in
  let oR = [] in
  let aR = [] in
  let ik = IK_simple in
  let Nias = [NIAFP_successor] in
  let Dia = DIAFP_none in
  match instr with
  | B (LI,AA,LK) ->
     let oR = NIA_fp :: oR in
     let iR = if bitU_to_bool AA then CIA_fp :: iR else iR in
     let oR = if bitU_to_bool LK then (RFull "LR") :: oR else oR in
     (if bitU_to_bool AA
      then
        return (set_vector_start 0
          (exts ((64:ii),reset_vector_start (LI ^^ (Vector [B0;B0] 0 true)))))
      else
        read_reg CIA >>= fun w__0 ->
        return (set_vector_start 0
          (add_VVV
             w__0
             (reset_vector_start (exts ((64:ii),reset_vector_start (LI ^^ (Vector [B0;B0] 0 true)))))))) >>= fun nia' ->
     let Nias = [NIAFP_concrete_address (reset_vector_start nia')] in
     let ik = IK_simple in
     return (aR,oR,iR,Nias,ik)
  | Bc (BO,BI,BD,AA,LK) ->
     let iR = mode64bit_fp :: iR in
     let iR = (RFull "CTR") :: iR in
     let oR = if bitU_to_bool (~(access BO (2:ii))) then (RFull "CTR") :: oR else oR in
     let iR = (RSliceBit ("CR",add_VII (reset_vector_start BI) (32:ii))) :: iR in
     let oR = NIA_fp :: oR in
     let iR = if bitU_to_bool AA then CIA_fp :: iR else iR in
     (if bitU_to_bool AA
      then
        return (set_vector_start 0
          (exts ((64:ii),reset_vector_start (BD ^^ (Vector [B0;B0] 0 true)))))
      else
        read_reg CIA >>= fun w__1 ->
        return (set_vector_start 0
          (add_VVV
             w__1
             (reset_vector_start (exts ((64:ii),reset_vector_start (BD ^^ (Vector [B0;B0] 0 true)))))))) >>= fun w__2 ->
     let Nias = [NIAFP_concrete_address (reset_vector_start w__2);NIAFP_successor] in
     let (oR, iR) =
       if bitU_to_bool LK
       then
         let oR = (RFull "LR") :: oR in
         let iR = CIA_fp :: iR in
         (oR,iR)
       else (oR,iR) in
     let ik = IK_cond_branch in
     return (aR,oR,iR,Nias,ik)
  | Bclr (BO,BI,BH,LK) ->
     let iR = mode64bit_fp :: iR in
     let iR = (RFull "CTR") :: iR in
     let oR = if bitU_to_bool (~(access BO (2:ii))) then (RFull "CTR") :: oR else oR in
     let iR = (RSliceBit ("CR",add_VII (reset_vector_start BI) (32:ii))) :: iR in
     let iR = (RSlice ("LR",(0:ii),(61:ii))) :: iR in
     let oR = NIA_fp :: oR in
     let Nias = [NIAFP_LR;NIAFP_successor] in
     let (oR, iR) =
       if bitU_to_bool LK
       then
         let oR = (RFull "LR") :: oR in
         let iR = CIA_fp :: iR in
         (oR,iR)
       else (oR,iR) in
     let ik = IK_cond_branch in
     return (aR,oR,iR,Nias,ik)
  | Bcctr (BO,BI,BH,LK) ->
     let iR = (RSliceBit ("CR",add_VII (reset_vector_start BI) (32:ii))) :: iR in
     let iR = (RSlice ("CTR",(0:ii),(61:ii))) :: iR in
     let oR = NIA_fp :: oR in
     let Nias = [NIAFP_CTR;NIAFP_successor] in
     let (oR, iR) =
       if bitU_to_bool LK
       then
         let oR = (RFull "LR") :: oR in
         let iR = CIA_fp :: iR in
         (oR,iR)
       else (oR,iR) in
     let ik = IK_cond_branch in
     return (aR,oR,iR,Nias,ik)
  | Crand (BT,BA,BB) ->
     let iR =
       (RSliceBit ("CR",add_VII (reset_vector_start BA) (32:ii))) ::
         (RSliceBit ("CR",add_VII (reset_vector_start BB) (32:ii))) :: iR in
     let oR = (RSliceBit ("CR",add_VII (reset_vector_start BT) (32:ii))) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Crnand (BT,BA,BB) ->
     let iR =
       (RSliceBit ("CR",add_VII (reset_vector_start BA) (32:ii))) ::
         (RSliceBit ("CR",add_VII (reset_vector_start BB) (32:ii))) :: iR in
     let oR = (RSliceBit ("CR",add_VII (reset_vector_start BT) (32:ii))) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Cror (BT,BA,BB) ->
     let iR =
       (RSliceBit ("CR",add_VII (reset_vector_start BA) (32:ii))) ::
         (RSliceBit ("CR",add_VII (reset_vector_start BB) (32:ii))) :: iR in
     let oR = (RSliceBit ("CR",add_VII (reset_vector_start BT) (32:ii))) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Crxor (BT,BA,BB) ->
     let iR =
       (RSliceBit ("CR",add_VII (reset_vector_start BA) (32:ii))) ::
         (RSliceBit ("CR",add_VII (reset_vector_start BB) (32:ii))) :: iR in
     let oR = (RSliceBit ("CR",add_VII (reset_vector_start BT) (32:ii))) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Crnor (BT,BA,BB) ->
     let iR =
       (RSliceBit ("CR",add_VII (reset_vector_start BA) (32:ii))) ::
         (RSliceBit ("CR",add_VII (reset_vector_start BB) (32:ii))) :: iR in
     let oR = (RSliceBit ("CR",add_VII (reset_vector_start BT) (32:ii))) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Creqv (BT,BA,BB) ->
     let iR =
       (RSliceBit ("CR",add_VII (reset_vector_start BA) (32:ii))) ::
         (RSliceBit ("CR",add_VII (reset_vector_start BB) (32:ii))) :: iR in
     let oR = (RSliceBit ("CR",add_VII (reset_vector_start BT) (32:ii))) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Crandc (BT,BA,BB) ->
     let iR =
       (RSliceBit ("CR",add_VII (reset_vector_start BA) (32:ii))) ::
         (RSliceBit ("CR",add_VII (reset_vector_start BB) (32:ii))) :: iR in
     let oR = (RSliceBit ("CR",add_VII (reset_vector_start BT) (32:ii))) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Crorc (BT,BA,BB) ->
     let iR =
       (RSliceBit ("CR",add_VII (reset_vector_start BA) (32:ii))) ::
         (RSliceBit ("CR",add_VII (reset_vector_start BB) (32:ii))) :: iR in
     let oR = (RSliceBit ("CR",add_VII (reset_vector_start BT) (32:ii))) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Mcrf (BF,BFA) ->
     let iR =
       (RSlice ("CR",add_VII (reset_vector_start (mult_IVV (4:ii) (reset_vector_start BFA))) (32:ii),add_VII
                                                                                                       (reset_vector_start (mult_IVV
                                                                                                                              (4:ii)
                                                                                                                              (reset_vector_start BFA)))
                                                                                                       (35:ii))) ::
         iR in
     let oR =
       (RSlice ("CR",add_VII (reset_vector_start (mult_IVV (4:ii) (reset_vector_start BF))) (32:ii),add_VII
                                                                                                      (reset_vector_start (mult_IVV
                                                                                                                             (4:ii)
                                                                                                                             (reset_vector_start BF)))
                                                                                                      (35:ii))) ::
         oR in
     return (aR,oR,iR,Nias,ik)
  | Sc (LEV) ->
     let Nias = if bitU_to_bool (eq_vec_range (LEV, (63:ii))) then [] else [NIAFP_successor] in
     return (aR,oR,iR,Nias,ik)
  | Scv (LEV) -> return (aR,oR,iR,Nias,ik)
  | Lbz (RT,RA,D) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let aR = iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Lbzx (RT,RA,RB) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Lbzu (RT,RA,D) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let aR = iR in
     let oR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Lbzux (RT,RA,RB) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let oR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Lhz (RT,RA,D) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let aR = iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Lhzx (RT,RA,RB) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Lhzu (RT,RA,D) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let aR = iR in
     let oR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Lhzux (RT,RA,RB) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let oR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Lha (RT,RA,D) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let aR = iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Lhax (RT,RA,RB) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Lhau (RT,RA,D) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let aR = iR in
     let oR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Lhaux (RT,RA,RB) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let oR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Lwz (RT,RA,D) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let aR = iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Lwzx (RT,RA,RB) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Lwzu (RT,RA,D) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let aR = iR in
     let oR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Lwzux (RT,RA,RB) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let oR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Lwa (RT,RA,DS) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let aR = iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Lwax (RT,RA,RB) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Lwaux (RT,RA,RB) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let oR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Ld (RT,RA,DS) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let aR = iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Ldx (RT,RA,RB) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Ldu (RT,RA,DS) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let aR = iR in
     let oR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Ldux (RT,RA,RB) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let oR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Stb (RS,RA,D) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let aR = iR in
     let iR = (RSlice (access GPRs (unsigned (reset_vector_start RS)),(56:ii),(63:ii))) :: iR in
     let ik = IK_mem_write Write_plain in
     return (aR,oR,iR,Nias,ik)
  | Stbx (RS,RA,RB) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let iR = (RSlice (access GPRs (unsigned (reset_vector_start RS)),(56:ii),(63:ii))) :: iR in
     let ik = IK_mem_write Write_plain in
     return (aR,oR,iR,Nias,ik)
  | Stbu (RS,RA,D) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let aR = iR in
     let iR = (RSlice (access GPRs (unsigned (reset_vector_start RS)),(56:ii),(63:ii))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let ik = IK_mem_write Write_plain in
     return (aR,oR,iR,Nias,ik)
  | Stbux (RS,RA,RB) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let aR = iR in
     let iR = (RSlice (access GPRs (unsigned (reset_vector_start RS)),(56:ii),(63:ii))) :: iR in
     let ik = IK_mem_write Write_plain in
     return (aR,oR,iR,Nias,ik)
  | Sth (RS,RA,D) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let aR = iR in
     let iR = (RSlice (access GPRs (unsigned (reset_vector_start RS)),(48:ii),(63:ii))) :: iR in
     let ik = IK_mem_write Write_plain in
     return (aR,oR,iR,Nias,ik)
  | Sthx (RS,RA,RB) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RB)))) ::
         (RSlice (access GPRs (unsigned (reset_vector_start RS)),(48:ii),(63:ii))) :: iR in
     let ik = IK_mem_write Write_plain in
     return (aR,oR,iR,Nias,ik)
  | Sthu (RS,RA,D) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let aR = iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let iR = (RSlice (access GPRs (unsigned (reset_vector_start RS)),(48:ii),(63:ii))) :: iR in
     let ik = IK_mem_write Write_plain in
     return (aR,oR,iR,Nias,ik)
  | Sthux (RS,RA,RB) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let aR = iR in
     let iR = (RSlice (access GPRs (unsigned (reset_vector_start RS)),(48:ii),(63:ii))) :: iR in
     let ik = IK_mem_write Write_plain in
     return (aR,oR,iR,Nias,ik)
  | Stw (RS,RA,D) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let aR = iR in
     let iR = (RSlice (access GPRs (unsigned (reset_vector_start RS)),(32:ii),(63:ii))) :: iR in
     let ik = IK_mem_write Write_plain in
     return (aR,oR,iR,Nias,ik)
  | Stwx (RS,RA,RB) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let iR = (RSlice (access GPRs (unsigned (reset_vector_start RS)),(32:ii),(63:ii))) :: iR in
     let ik = IK_mem_write Write_plain in
     return (aR,oR,iR,Nias,ik)
  | Stwu (RS,RA,D) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let aR = iR in
     let iR = (RSlice (access GPRs (unsigned (reset_vector_start RS)),(32:ii),(63:ii))) :: iR in
     let ik = IK_mem_write Write_plain in
     return (aR,oR,iR,Nias,ik)
  | Stwux (RS,RA,RB) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let aR = iR in
     let iR = (RSlice (access GPRs (unsigned (reset_vector_start RS)),(32:ii),(63:ii))) :: iR in
     let ik = IK_mem_write Write_plain in
     return (aR,oR,iR,Nias,ik)
  | Std (RS,RA,DS) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let aR = iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RS)))) :: iR in
     let ik = IK_mem_write Write_plain in
     return (aR,oR,iR,Nias,ik)
  | Stdx (RS,RA,RB) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RS)))) :: iR in
     let ik = IK_mem_write Write_plain in
     return (aR,oR,iR,Nias,ik)
  | Stdu (RS,RA,DS) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let aR = iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RS)))) :: iR in
     let ik = IK_mem_write Write_plain in
     return (aR,oR,iR,Nias,ik)
  | Stdux (RS,RA,RB) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let aR = iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RS)))) :: iR in
     let ik = IK_mem_write Write_plain in
     return (aR,oR,iR,Nias,ik)
  | Lq (RTp,RA,DQ,PT) ->
     let iR = bigendianmode_fp :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let aR = iR in
     let oR =
       (RFull (access GPRs (unsigned (reset_vector_start RTp)))) ::
         (RFull (access GPRs (add_VII (reset_vector_start RTp) (1:ii)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Stq (RSp,RA,DS) ->
     let iR = bigendianmode_fp :: iR in
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let aR = iR in
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RSp)))) ::
         (RFull (access GPRs (add_VII (reset_vector_start RSp) (1:ii)))) :: iR in
     let ik = IK_mem_write Write_plain in
     return (aR,oR,iR,Nias,ik)
  | Lhbrx (RT,RA,RB) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Sthbrx (RS,RA,RB) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let iR =
       (RSlice (access GPRs (unsigned (reset_vector_start RS)),(56:ii),(63:ii))) ::
         (RSlice (access GPRs (unsigned (reset_vector_start RS)),(48:ii),(55:ii))) :: iR in
     let ik = IK_mem_write Write_plain in
     return (aR,oR,iR,Nias,ik)
  | Lwbrx (RT,RA,RB) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Stwbrx (RS,RA,RB) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let iR =
       (RSlice (access GPRs (unsigned (reset_vector_start RS)),(56:ii),(63:ii))) ::
         (RSlice (access GPRs (unsigned (reset_vector_start RS)),(48:ii),(55:ii))) ::
           (RSlice (access GPRs (unsigned (reset_vector_start RS)),(40:ii),(47:ii))) ::
             (RSlice (access GPRs (unsigned (reset_vector_start RS)),(32:ii),(39:ii))) :: iR in
     let ik = IK_mem_write Write_plain in
     return (aR,oR,iR,Nias,ik)
  | Ldbrx (RT,RA,RB) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Stdbrx (RS,RA,RB) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let iR =
       (RSlice (access GPRs (unsigned (reset_vector_start RS)),(56:ii),(63:ii))) ::
         (RSlice (access GPRs (unsigned (reset_vector_start RS)),(48:ii),(55:ii))) ::
           (RSlice (access GPRs (unsigned (reset_vector_start RS)),(40:ii),(47:ii))) ::
             (RSlice (access GPRs (unsigned (reset_vector_start RS)),(32:ii),(39:ii))) ::
               (RSlice (access GPRs (unsigned (reset_vector_start RS)),(24:ii),(31:ii))) ::
                 (RSlice (access GPRs (unsigned (reset_vector_start RS)),(16:ii),(23:ii))) ::
                   (RSlice (access GPRs (unsigned (reset_vector_start RS)),(8:ii),(15:ii))) ::
                     (RSlice (access GPRs (unsigned (reset_vector_start RS)),(0:ii),(7:ii))) :: iR in
     let ik = IK_mem_write Write_plain in
     return (aR,oR,iR,Nias,ik)
  | Lmw (RT,RA,D) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let i = (0:ii) in
     let aR = iR in
     let (i, oR) =
       (foreach_inc (unsigned (reset_vector_start RT),(31:ii),(1:ii)) (i,oR)
         (fun r (i,oR) ->
          let oR = (RFull (access GPRs r)) :: oR in
          let i = i + (32:ii) in
          (i,oR))) in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Stmw (RS,RA,D) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let aR = iR in
     let i = (0:ii) in
     let (i, iR) =
       (foreach_inc (unsigned (reset_vector_start RS),(31:ii),(1:ii)) (i,iR)
         (fun r (i,iR) ->
          let iR = (RSlice (access GPRs r,(32:ii),(63:ii))) :: iR in
          let i = i + (32:ii) in
          (i,iR))) in
     let ik = IK_mem_write Write_plain in
     return (aR,oR,iR,Nias,ik)
  | Lswi (RT,RA,NB) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let aR = iR in
     let r = (0:ii) in
     let r = minus_VII (reset_vector_start RT) (1:ii) in
     let j = (0:ii) in
     let i = (32:ii) in
     let (i, j, oR, r) =
       (foreach_dec (if bitU_to_bool (eq_vec_range (NB, (0:ii)))
       then (32:ii)
       else unsigned (reset_vector_start NB),(1:ii),(1:ii)) (i,j,oR,r)
         (fun n (i,j,oR,r) ->
          let (r, oR) =
            if bitU_to_bool (eq_range (i, (32:ii)))
            then
              let r = modulo (r + (1:ii)) (32:ii) in
              let oR = (RFull (access GPRs r)) :: oR in
              (r,oR)
            else (r,oR) in
          let oR = (RSlice (access GPRs r,i,i + (7:ii))) :: oR in
          let j = j + (8:ii) in
          let i = i + (8:ii) in
          let i = if bitU_to_bool (eq_range (i, (64:ii))) then (32:ii) else i in
          (i,j,oR,r))) in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Lswx (RT,RA,RB) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RB)))) ::
         (RSlice ("XER",(57:ii),(63:ii))) :: iR in
     let aR = iR in
     let oR = (foreach_inc ((0:ii),(31:ii),(1:ii)) oR (fun r oR -> (RFull (access GPRs r)) :: oR)) in
     let ik = IK_mem_read Read_plain in
     return (aR,oR,iR,Nias,ik)
  | Stswi (RS,RA,NB) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let aR = iR in
     let r = (0:ii) in
     let r = minus_VII (reset_vector_start RS) (1:ii) in
     let j = (0:ii) in
     let i = (32:ii) in
     let (i, j, iR, r) =
       (foreach_dec (if bitU_to_bool (eq_vec_range (NB, (0:ii)))
       then (32:ii)
       else unsigned (reset_vector_start NB),(1:ii),(1:ii)) (i,j,iR,r)
         (fun n (i,j,iR,r) ->
          let r = if bitU_to_bool (eq_range (i, (32:ii))) then modulo (r + (1:ii)) (32:ii) else r in
          let iR = (RSlice (access GPRs r,i,i + (7:ii))) :: iR in
          let j = j + (8:ii) in
          let i = i + (8:ii) in
          let i = if bitU_to_bool (eq_range (i, (64:ii))) then (32:ii) else i in
          (i,j,iR,r))) in
     let ik = IK_mem_write Write_plain in
     return (aR,oR,iR,Nias,ik)
  | Stswx (RS,RA,RB) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let r = (0:ii) in
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RB)))) ::
         (RSlice ("XER",(57:ii),(63:ii))) :: iR in
     let aR = iR in
     let r = minus_VII (reset_vector_start RS) (1:ii) in
     let i = (32:ii) in
     let n_top = unsigned (reset_vector_start (Vector [B1;B1;B1;B1;B1;B1;B1] 0 true)) in
     let j = (0:ii) in
     let (j, i, iR, r) =
       (foreach_dec (n_top,(1:ii),(1:ii)) (j,i,iR,r)
         (fun n (j,i,iR,r) ->
          let r = if bitU_to_bool (eq_range (i, (32:ii))) then modulo (r + (1:ii)) (32:ii) else r in
          let iR = (RSlice (access GPRs r,i,i + (7:ii))) :: iR in
          let i = i + (8:ii) in
          let j = j + (8:ii) in
          let i = if bitU_to_bool (eq_range (i, (64:ii))) then (32:ii) else i in
          (j,i,iR,r))) in
     let ik = IK_mem_write Write_plain in
     return (aR,oR,iR,Nias,ik)
  | Addi (RT,RA,SI) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Addis (RT,RA,SI) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Add (RT,RA,RB,OE,Rc) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let (iR, oR) =
       if bitU_to_bool OE
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("XER","OV")) :: (RField ("XER","SO")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Subf (RT,RA,RB,OE,Rc) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let (iR, oR) =
       if bitU_to_bool OE
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("XER","OV")) :: (RField ("XER","SO")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Addic (RT,RA,SI) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let oR =
       (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: (RField ("XER","CA")) :: oR in
     return (aR,oR,iR,Nias,ik)
  | AddicDot (RT,RA,SI) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let oR =
       (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: (RField ("XER","CA")) :: oR in
     let iR = (RField ("XER","SO")) :: iR in
     let oR = (RField ("CR","CR0")) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Subfic (RT,RA,SI) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let oR =
       (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: (RField ("XER","CA")) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Addc (RT,RA,RB,OE,Rc) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let oR = (RField ("XER","CA")) :: oR in
     let (iR, oR) =
       if bitU_to_bool OE
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("XER","OV")) :: (RField ("XER","SO")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Subfc (RT,RA,RB,OE,Rc) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let oR = (RField ("XER","CA")) :: oR in
     let (iR, oR) =
       if bitU_to_bool OE
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("XER","OV")) :: (RField ("XER","SO")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Adde (RT,RA,RB,OE,Rc) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let iR = (RField ("XER","CA")) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let oR = (RField ("XER","CA")) :: oR in
     let (iR, oR) =
       if bitU_to_bool OE
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("XER","OV")) :: (RField ("XER","SO")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Subfe (RT,RA,RB,OE,Rc) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let iR = (RField ("XER","CA")) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let oR = (RField ("XER","CA")) :: oR in
     let (iR, oR) =
       if bitU_to_bool OE
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("XER","OV")) :: (RField ("XER","SO")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Addme (RT,RA,OE,Rc) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: (RField ("XER","CA")) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let oR = (RField ("XER","CA")) :: oR in
     let (iR, oR) =
       if bitU_to_bool OE
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("XER","OV")) :: (RField ("XER","SO")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Subfme (RT,RA,OE,Rc) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: (RField ("XER","CA")) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let oR = (RField ("XER","CA")) :: oR in
     let (iR, oR) =
       if bitU_to_bool OE
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("XER","OV")) :: (RField ("XER","SO")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Addze (RT,RA,OE,Rc) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: (RField ("XER","CA")) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let oR = (RField ("XER","CA")) :: oR in
     let (iR, oR) =
       if bitU_to_bool OE
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("XER","OV")) :: (RField ("XER","SO")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Subfze (RT,RA,OE,Rc) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: (RField ("XER","CA")) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let oR = (RField ("XER","CA")) :: oR in
     let (iR, oR) =
       if bitU_to_bool OE
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("XER","OV")) :: (RField ("XER","SO")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Neg (RT,RA,OE,Rc) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let (iR, oR) =
       if bitU_to_bool OE
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("XER","OV")) :: (RField ("XER","SO")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Mulli (RT,RA,SI) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Mullw (RT,RA,RB,OE,Rc) ->
     let iR =
       (RSlice (access GPRs (unsigned (reset_vector_start RA)),(32:ii),(63:ii))) ::
         (RSlice (access GPRs (unsigned (reset_vector_start RB)),(32:ii),(63:ii))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let (iR, oR) =
       if bitU_to_bool OE
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("XER","OV")) :: (RField ("XER","SO")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Mulhw (RT,RA,RB,Rc) ->
     let iR =
       (RSlice (access GPRs (unsigned (reset_vector_start RA)),(32:ii),(63:ii))) ::
         (RSlice (access GPRs (unsigned (reset_vector_start RB)),(32:ii),(63:ii))) :: iR in
     let oR =
       (RSlice (access GPRs (unsigned (reset_vector_start RT)),(32:ii),(63:ii))) ::
         (RSlice (access GPRs (unsigned (reset_vector_start RT)),(0:ii),(31:ii))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = mode64bit_fp :: iR in
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Mulhwu (RT,RA,RB,Rc) ->
     let iR =
       (RSlice (access GPRs (unsigned (reset_vector_start RA)),(32:ii),(63:ii))) ::
         (RSlice (access GPRs (unsigned (reset_vector_start RB)),(32:ii),(63:ii))) :: iR in
     let oR =
       (RSlice (access GPRs (unsigned (reset_vector_start RT)),(32:ii),(63:ii))) ::
         (RSlice (access GPRs (unsigned (reset_vector_start RT)),(0:ii),(31:ii))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = mode64bit_fp :: iR in
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Divw (RT,RA,RB,OE,Rc) ->
     let iR =
       (RSlice (access GPRs (unsigned (reset_vector_start RA)),(32:ii),(63:ii))) ::
         (RSlice (access GPRs (unsigned (reset_vector_start RB)),(32:ii),(63:ii))) :: iR in
     let oR =
       (RSlice (access GPRs (unsigned (reset_vector_start RT)),(32:ii),(63:ii))) ::
         (RSlice (access GPRs (unsigned (reset_vector_start RT)),(0:ii),(31:ii))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = mode64bit_fp :: iR in
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let (iR, oR) =
       if bitU_to_bool OE
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("XER","OV")) :: (RField ("XER","SO")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Divwu (RT,RA,RB,OE,Rc) ->
     let iR =
       (RSlice (access GPRs (unsigned (reset_vector_start RA)),(32:ii),(63:ii))) ::
         (RSlice (access GPRs (unsigned (reset_vector_start RB)),(32:ii),(63:ii))) :: iR in
     let oR =
       (RSlice (access GPRs (unsigned (reset_vector_start RT)),(32:ii),(63:ii))) ::
         (RSlice (access GPRs (unsigned (reset_vector_start RT)),(0:ii),(31:ii))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = mode64bit_fp :: iR in
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let (iR, oR) =
       if bitU_to_bool OE
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("XER","OV")) :: (RField ("XER","SO")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Divwe (RT,RA,RB,OE,Rc) ->
     let iR =
       (RSlice (access GPRs (unsigned (reset_vector_start RA)),(32:ii),(63:ii))) ::
         (RSlice (access GPRs (unsigned (reset_vector_start RB)),(32:ii),(63:ii))) :: iR in
     let oR =
       (RSlice (access GPRs (unsigned (reset_vector_start RT)),(32:ii),(63:ii))) ::
         (RSlice (access GPRs (unsigned (reset_vector_start RT)),(0:ii),(31:ii))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = mode64bit_fp :: iR in
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let (iR, oR) =
       if bitU_to_bool OE
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("XER","OV")) :: (RField ("XER","SO")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Divweu (RT,RA,RB,OE,Rc) ->
     let iR =
       (RSlice (access GPRs (unsigned (reset_vector_start RA)),(32:ii),(63:ii))) ::
         (RSlice (access GPRs (unsigned (reset_vector_start RB)),(32:ii),(63:ii))) :: iR in
     let oR =
       (RSlice (access GPRs (unsigned (reset_vector_start RT)),(32:ii),(63:ii))) ::
         (RSlice (access GPRs (unsigned (reset_vector_start RT)),(0:ii),(31:ii))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = mode64bit_fp :: iR in
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let (iR, oR) =
       if bitU_to_bool OE
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("XER","OV")) :: (RField ("XER","SO")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Mulld (RT,RA,RB,OE,Rc) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let (iR, oR) =
       if bitU_to_bool OE
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("XER","OV")) :: (RField ("XER","SO")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Mulhd (RT,RA,RB,Rc) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Mulhdu (RT,RA,RB,Rc) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Divd (RT,RA,RB,OE,Rc) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let (iR, oR) =
       if bitU_to_bool OE
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("XER","OV")) :: (RField ("XER","SO")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Divdu (RT,RA,RB,OE,Rc) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let (iR, oR) =
       if bitU_to_bool OE
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("XER","OV")) :: (RField ("XER","SO")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Divde (RT,RA,RB,OE,Rc) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let (iR, oR) =
       if bitU_to_bool OE
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("XER","OV")) :: (RField ("XER","SO")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Divdeu (RT,RA,RB,OE,Rc) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let (iR, oR) =
       if bitU_to_bool OE
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("XER","OV")) :: (RField ("XER","SO")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Cmpi (BF,L,RA,SI) ->
     let iR =
       (if bitU_to_bool (eq (match L with | B0 -> (0:ii) | B1 -> (1:ii) end, (0:ii)))
        then RSlice (access GPRs (unsigned (reset_vector_start RA)),(32:ii),(63:ii))
        else RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         iR in
     let iR = (RField ("XER","SO")) :: iR in
     let oR =
       (RSlice ("CR",add_VII (reset_vector_start (mult_IVV (4:ii) (reset_vector_start BF))) (32:ii),add_VII
                                                                                                      (reset_vector_start (mult_IVV
                                                                                                                             (4:ii)
                                                                                                                             (reset_vector_start BF)))
                                                                                                      (35:ii))) ::
         oR in
     return (aR,oR,iR,Nias,ik)
  | Cmp (BF,L,RA,RB) ->
     let iR =
       if bitU_to_bool (eq (match L with | B0 -> (0:ii) | B1 -> (1:ii) end, (0:ii)))
       then
         (RSlice (access GPRs (unsigned (reset_vector_start RA)),(32:ii),(63:ii))) ::
           (RSlice (access GPRs (unsigned (reset_vector_start RB)),(32:ii),(63:ii))) :: iR
       else
         (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
           (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let iR = (RField ("XER","SO")) :: iR in
     let oR =
       (RSlice ("CR",unsigned (reset_vector_start (mult_IVV (4:ii) (reset_vector_start BF))),add_VII
                                                                                               (reset_vector_start (mult_IVV
                                                                                                                      (4:ii)
                                                                                                                      (reset_vector_start BF)))
                                                                                               (35:ii))) ::
         oR in
     return (aR,oR,iR,Nias,ik)
  | Cmpli (BF,L,RA,UI) ->
     let iR =
       (if bitU_to_bool (eq (match L with | B0 -> (0:ii) | B1 -> (1:ii) end, (0:ii)))
        then RSlice (access GPRs (unsigned (reset_vector_start RA)),(32:ii),(63:ii))
        else RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
         iR in
     let iR = (RField ("XER","SO")) :: iR in
     let oR =
       (RSlice ("CR",add_VII (reset_vector_start (mult_IVV (4:ii) (reset_vector_start BF))) (32:ii),add_VII
                                                                                                      (reset_vector_start (mult_IVV
                                                                                                                             (4:ii)
                                                                                                                             (reset_vector_start BF)))
                                                                                                      (35:ii))) ::
         oR in
     return (aR,oR,iR,Nias,ik)
  | Cmpl (BF,L,RA,RB) ->
     let iR =
       if bitU_to_bool (eq (match L with | B0 -> (0:ii) | B1 -> (1:ii) end, (0:ii)))
       then
         (RSlice (access GPRs (unsigned (reset_vector_start RA)),(32:ii),(63:ii))) ::
           (RSlice (access GPRs (unsigned (reset_vector_start RB)),(32:ii),(63:ii))) :: iR
       else
         (RFull (access GPRs (unsigned (reset_vector_start RA)))) ::
           (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let iR = (RField ("XER","SO")) :: iR in
     let oR =
       (RSlice ("CR",add_VII (reset_vector_start (mult_IVV (4:ii) (reset_vector_start BF))) (32:ii),add_VII
                                                                                                      (reset_vector_start (mult_IVV
                                                                                                                             (4:ii)
                                                                                                                             (reset_vector_start BF)))
                                                                                                      (35:ii))) ::
         oR in
     return (aR,oR,iR,Nias,ik)
  | Isel (RT,RA,RB,BC) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let iR = (RSliceBit ("CR",add_VII (reset_vector_start BC) (32:ii))) :: iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Andi (RS,RA,UI) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RS)))) :: (RField ("XER","SO")) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let oR = (RField ("CR","CR0")) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Andis (RS,RA,UI) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RS)))) :: (RField ("XER","SO")) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let oR = (RField ("CR","CR0")) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Ori (RS,RA,UI) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RS)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Oris (RS,RA,UI) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RS)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Xori (RS,RA,UI) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RS)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Xoris (RS,RA,UI) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RS)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     return (aR,oR,iR,Nias,ik)
  | And (RS,RA,RB,Rc) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RS)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Xor (RS,RA,RB,Rc) ->
     let (iR, oR) =
       if bitU_to_bool (eq_vec (RS, RB))
       then
         let iR = (RFull (access GPRs (unsigned (reset_vector_start RS)))) :: iR in
         let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
         (iR,oR)
       else
         let iR =
           (RFull (access GPRs (unsigned (reset_vector_start RS)))) ::
             (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
         let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
         (iR,oR) in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Nand (RS,RA,RB,Rc) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RS)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Or (RS,RA,RB,Rc) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RS)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Nor (RS,RA,RB,Rc) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RS)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Eqv (RS,RA,RB,Rc) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RS)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Andc (RS,RA,RB,Rc) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RS)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Orc (RS,RA,RB,Rc) ->
     let iR =
       (RFull (access GPRs (unsigned (reset_vector_start RS)))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Extsb (RS,RA,Rc) ->
     let iR = (RSliceBit (access GPRs (unsigned (reset_vector_start RS)),(56:ii))) :: iR in
     let iR = (RSlice (access GPRs (unsigned (reset_vector_start RS)),(56:ii),(63:ii))) :: iR in
     let oR = (RSlice (access GPRs (unsigned (reset_vector_start RA)),(56:ii),(63:ii))) :: oR in
     let oR = (RSlice (access GPRs (unsigned (reset_vector_start RA)),(0:ii),(55:ii))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Extsh (RS,RA,Rc) ->
     let iR = (RSliceBit (access GPRs (unsigned (reset_vector_start RS)),(48:ii))) :: iR in
     let iR = (RSlice (access GPRs (unsigned (reset_vector_start RS)),(48:ii),(63:ii))) :: iR in
     let oR = (RSlice (access GPRs (unsigned (reset_vector_start RA)),(48:ii),(63:ii))) :: oR in
     let oR = (RSlice (access GPRs (unsigned (reset_vector_start RA)),(0:ii),(47:ii))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Cntlzw (RS,RA,Rc) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RS)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Cmpb (RS,RA,RB) ->
     let (oR, iR) =
       (foreach_inc ((0:ii),(7:ii),(1:ii)) (oR,iR)
         (fun n (oR,iR) ->
          let iR =
            (RSlice (access GPRs (unsigned (reset_vector_start RS)),(8:ii) * n,((8:ii) * n) + (7:ii))) ::
              (RSlice (access GPRs (unsigned (reset_vector_start RB)),(8:ii) * n,((8:ii) * n) +
                                                                                   (7:ii))) ::
                iR in
          let oR =
            (RSlice (access GPRs (unsigned (reset_vector_start RA)),(8:ii) * n,((8:ii) * n) + (7:ii))) ::
              oR in
          (oR,iR))) in
     return (aR,oR,iR,Nias,ik)
  | Popcntb (RS,RA) ->
     let (oR, iR) =
       (foreach_inc ((0:ii),(7:ii),(1:ii)) (oR,iR)
         (fun i (oR,iR) ->
          let iR =
            (foreach_inc ((0:ii),(7:ii),(1:ii)) iR
              (fun j iR ->
               (RSliceBit (access GPRs (unsigned (reset_vector_start RS)),(i * (8:ii)) + j)) :: iR)) in
          let oR =
            (RSlice (access GPRs (unsigned (reset_vector_start RA)),i * (8:ii),(i * (8:ii)) + (7:ii))) ::
              oR in
          (oR,iR))) in
     return (aR,oR,iR,Nias,ik)
  | Popcntw (RS,RA) ->
     let (oR, iR) =
       (foreach_inc ((0:ii),(1:ii),(1:ii)) (oR,iR)
         (fun i (oR,iR) ->
          let iR =
            (foreach_inc ((0:ii),(31:ii),(1:ii)) iR
              (fun j iR ->
               (RSliceBit (access GPRs (unsigned (reset_vector_start RS)),(i * (32:ii)) + j)) :: iR)) in
          let oR =
            (RSlice (access GPRs (unsigned (reset_vector_start RA)),i * (32:ii),(i * (32:ii)) +
                                                                                  (31:ii))) ::
              oR in
          (oR,iR))) in
     return (aR,oR,iR,Nias,ik)
  | Prtyd (RS,RA) ->
     let iR =
       (foreach_inc ((0:ii),(7:ii),(1:ii)) iR
         (fun i iR ->
          (RSliceBit (access GPRs (unsigned (reset_vector_start RS)),(i * (8:ii)) + (7:ii))) :: iR)) in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Prtyw (RS,RA) ->
     let iR =
       (foreach_inc ((0:ii),(3:ii),(1:ii)) iR
         (fun i iR ->
          (RSliceBit (access GPRs (unsigned (reset_vector_start RS)),(i * (8:ii)) + (7:ii))) :: iR)) in
     let iR =
       (foreach_inc ((4:ii),(7:ii),(1:ii)) iR
         (fun i iR ->
          (RSliceBit (access GPRs (unsigned (reset_vector_start RS)),(i * (8:ii)) + (7:ii))) :: iR)) in
     let oR = (RSlice (access GPRs (unsigned (reset_vector_start RA)),(0:ii),(31:ii))) :: oR in
     let oR = (RSlice (access GPRs (unsigned (reset_vector_start RA)),(32:ii),(63:ii))) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Extsw (RS,RA,Rc) ->
     let iR = (RSliceBit (access GPRs (unsigned (reset_vector_start RS)),(32:ii))) :: iR in
     let iR = (RSlice (access GPRs (unsigned (reset_vector_start RS)),(32:ii),(63:ii))) :: iR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Cntlzd (RS,RA,Rc) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RS)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Popcntd (RS,RA) ->
     let iR =
       (foreach_inc ((0:ii),(63:ii),(1:ii)) iR
         (fun i iR -> (RSliceBit (access GPRs (unsigned (reset_vector_start RS)),i)) :: iR)) in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Bpermd (RS,RA,RB) ->
     let (oR, iR) =
       (foreach_inc ((0:ii),(7:ii),(1:ii)) (oR,iR)
         (fun i (oR,iR) ->
          let iR =
            (RSlice (access GPRs (unsigned (reset_vector_start RS)),(8:ii) * i,((8:ii) * i) + (7:ii))) ::
              iR in
          let iR = (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
          let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
          (oR,iR))) in
     return (aR,oR,iR,Nias,ik)
  | Rlwinm (RS,RA,SH,MB,ME,Rc) ->
     let iR = (RSlice (access GPRs (unsigned (reset_vector_start RS)),(32:ii),(63:ii))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Rlwnm (RS,RA,RB,MB,ME,Rc) ->
     let iR =
       (RSlice (access GPRs (unsigned (reset_vector_start RB)),(59:ii),(63:ii))) ::
         (RSlice (access GPRs (unsigned (reset_vector_start RS)),(32:ii),(63:ii))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Rlwimi (RS,RA,SH,MB,ME,Rc) ->
     let iR = (RSlice (access GPRs (unsigned (reset_vector_start RS)),(32:ii),(63:ii))) :: iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Rldicl (RS,RA,sh,mb,Rc) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RS)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Rldicr (RS,RA,sh,me,Rc) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RS)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Rldic (RS,RA,sh,mb,Rc) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RS)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Rldcl (RS,RA,RB,mb,Rc) ->
     let iR = (RSlice (access GPRs (unsigned (reset_vector_start RB)),(58:ii),(63:ii))) :: iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RS)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Rldcr (RS,RA,RB,me,Rc) ->
     let iR = (RSlice (access GPRs (unsigned (reset_vector_start RB)),(58:ii),(63:ii))) :: iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RS)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Rldimi (RS,RA,sh,mb,Rc) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RS)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Slw (RS,RA,RB,Rc) ->
     let iR = (RSlice (access GPRs (unsigned (reset_vector_start RB)),(59:ii),(63:ii))) :: iR in
     let iR = (RSlice (access GPRs (unsigned (reset_vector_start RS)),(32:ii),(63:ii))) :: iR in
     let iR = (RSliceBit (access GPRs (unsigned (reset_vector_start RB)),(58:ii))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Srw (RS,RA,RB,Rc) ->
     let iR = (RSlice (access GPRs (unsigned (reset_vector_start RB)),(59:ii),(63:ii))) :: iR in
     let iR = (RSlice (access GPRs (unsigned (reset_vector_start RS)),(32:ii),(63:ii))) :: iR in
     let iR = (RSliceBit (access GPRs (unsigned (reset_vector_start RB)),(58:ii))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Srawi (RS,RA,SH,Rc) ->
     let iR = (RSlice (access GPRs (unsigned (reset_vector_start RS)),(32:ii),(63:ii))) :: iR in
     let iR = (RSliceBit (access GPRs (unsigned (reset_vector_start RS)),(32:ii))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let oR = (RField ("XER","CA")) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Sraw (RS,RA,RB,Rc) ->
     let iR = (RSlice (access GPRs (unsigned (reset_vector_start RB)),(59:ii),(63:ii))) :: iR in
     let iR =
       (RSlice (access GPRs (unsigned (reset_vector_start RS)),(32:ii),(63:ii))) ::
         (RSliceBit (access GPRs (unsigned (reset_vector_start RB)),(58:ii))) ::
           (RSliceBit (access GPRs (unsigned (reset_vector_start RS)),(32:ii))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let oR = (RField ("XER","CA")) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Sld (RS,RA,RB,Rc) ->
     let iR =
       (RSlice (access GPRs (unsigned (reset_vector_start RB)),(58:ii),(63:ii))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RS)))) :: iR in
     let iR = (RSliceBit (access GPRs (unsigned (reset_vector_start RB)),(57:ii))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Srd (RS,RA,RB,Rc) ->
     let iR =
       (RSlice (access GPRs (unsigned (reset_vector_start RB)),(58:ii),(63:ii))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RS)))) :: iR in
     let iR = (RSliceBit (access GPRs (unsigned (reset_vector_start RB)),(57:ii))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Sradi (RS,RA,sh,Rc) ->
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RS)))) :: iR in
     let iR = (RSliceBit (access GPRs (unsigned (reset_vector_start RS)),(0:ii))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let oR = (RField ("XER","CA")) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Srad (RS,RA,RB,Rc) ->
     let iR =
       (RSlice (access GPRs (unsigned (reset_vector_start RB)),(58:ii),(63:ii))) ::
         (RFull (access GPRs (unsigned (reset_vector_start RS)))) ::
           (RSliceBit (access GPRs (unsigned (reset_vector_start RB)),(57:ii))) ::
             (RSliceBit (access GPRs (unsigned (reset_vector_start RS)),(0:ii))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: oR in
     let (iR, oR) =
       if bitU_to_bool Rc
       then
         let iR = (RField ("XER","SO")) :: iR in
         let oR = (RField ("CR","CR0")) :: oR in
         (iR,oR)
       else (iR,oR) in
     let oR = (RField ("XER","CA")) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Cdtbcd (RS,RA) ->
     let (oR, iR) =
       (foreach_inc ((0:ii),(1:ii),(1:ii)) (oR,iR)
         (fun i (oR,iR) ->
          let n = i * (32:ii) in
          let iR =
            (RSlice (access GPRs (unsigned (reset_vector_start RS)),n + (12:ii),n + (31:ii))) :: iR in
          let oR =
            (RSlice (access GPRs (unsigned (reset_vector_start RA)),n + (0:ii),n + (31:ii))) :: oR in
          (oR,iR))) in
     return (aR,oR,iR,Nias,ik)
  | Cbcdtd (RS,RA) ->
     let (oR, iR) =
       (foreach_inc ((0:ii),(1:ii),(1:ii)) (oR,iR)
         (fun i (oR,iR) ->
          let n = i * (32:ii) in
          let iR =
            (RSlice (access GPRs (unsigned (reset_vector_start RS)),n + (8:ii),n + (31:ii))) :: iR in
          let oR =
            (RSlice (access GPRs (unsigned (reset_vector_start RA)),n + (0:ii),n + (31:ii))) :: oR in
          (oR,iR))) in
     return (aR,oR,iR,Nias,ik)
  | Addg6s (RT,RA,RB) ->
     let iR =
       (foreach_inc ((0:ii),(15:ii),(1:ii)) iR
         (fun i iR ->
          let iR =
            (RSlice (access GPRs (unsigned (reset_vector_start RA)),(4:ii) * i,(63:ii))) :: iR in
          (RSlice (access GPRs (unsigned (reset_vector_start RB)),(4:ii) * i,(63:ii))) :: iR)) in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Mtspr (RS,spr) ->
     let n = (slice spr (5:ii) (9:ii)) ^^ (slice spr (0:ii) (4:ii)) in
     let (iR, oR) =
       if bitU_to_bool (eq_vec_range (n, (1:ii)))
       then
         let iR = (RFull (access GPRs (unsigned (reset_vector_start RS)))) :: iR in
         let oR = (RFull "XER") :: oR in
         (iR,oR)
       else
         let iR = (RFull (access SPRs (unsigned (reset_vector_start n)))) :: iR in
         let (iR, oR) =
           if bitU_to_bool (eq_range (length_spr (unsigned (reset_vector_start n)), (64:ii)))
           then
             let iR = (RFull (access GPRs (unsigned (reset_vector_start RS)))) :: iR in
             let oR = (RFull (access SPRs (unsigned (reset_vector_start n)))) :: oR in
             (iR,oR)
           else
             let (iR, oR) =
               if bitU_to_bool (eq_vec_range (n, (152:ii)))
               then
                 let iR =
                   (RSlice (access GPRs (unsigned (reset_vector_start RS)),(32:ii),(63:ii))) :: iR in
                 let oR = (RFull "CTRL") :: oR in
                 (iR,oR)
               else (iR,oR) in
             (iR,oR) in
         (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Mfspr (RT,spr) ->
     let n = (slice spr (5:ii) (9:ii)) ^^ (slice spr (0:ii) (4:ii)) in
     let iR = (RFull (access SPRs (unsigned (reset_vector_start n)))) :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Mtcrf (RS,FXM) ->
     let iR =
       (RFull "CR") ::
         (RSlice (access GPRs (unsigned (reset_vector_start RS)),(32:ii),(63:ii))) :: iR in
     let oR = (RFull "CR") :: oR in
     return (aR,oR,iR,Nias,ik)
  | Mfcr (RT) ->
     let iR = (RFull "CR") :: iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Mtocrf (RS,FXM) ->
     let n = (0:ii) in
     let count = (0:ii) in
     let (count, n) =
       (foreach_inc ((0:ii),(7:ii),(1:ii)) (count,n)
         (fun i (count,n) ->
          let (n, count) =
            if bitU_to_bool
                 (eq (match (access FXM i) with | B0 -> (0:ii) | B1 -> (1:ii) end, (1:ii)))
            then
              let n = i in
              let count = count + (1:ii) in
              (n,count)
            else (n,count) in
          (count,n))) in
     let (oR, iR) =
       if bitU_to_bool (eq_range (count, (1:ii)))
       then
         let oR = (RSlice ("CR",((4:ii) * n) + (32:ii),((4:ii) * n) + (35:ii))) :: oR in
         let iR =
           (RSlice (access GPRs (unsigned (reset_vector_start RS)),((4:ii) * n) + (32:ii),((4:ii) *
                                                                                             n) +
                                                                                            (35:ii))) ::
             iR in
         (oR,iR)
       else
         let oR = (RFull "CR") :: oR in
         (oR,iR) in
     return (aR,oR,iR,Nias,ik)
  | Mfocrf (RT,FXM) ->
     let n = (0:ii) in
     let count = (0:ii) in
     let (count, n) =
       (foreach_inc ((0:ii),(7:ii),(1:ii)) (count,n)
         (fun i (count,n) ->
          let (n, count) =
            if bitU_to_bool
                 (eq (match (access FXM i) with | B0 -> (0:ii) | B1 -> (1:ii) end, (1:ii)))
            then
              let n = i in
              let count = count + (1:ii) in
              (n,count)
            else (n,count) in
          (count,n))) in
     let (iR, oR) =
       if bitU_to_bool (eq_range (count, (1:ii)))
       then
         let iR = (RSlice ("CR",((4:ii) * n) + (32:ii),((4:ii) * n) + (35:ii))) :: iR in
         let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
         (iR,oR)
       else
         let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
         (iR,oR) in
     return (aR,oR,iR,Nias,ik)
  | Mcrxr (BF) ->
     let iR = (RSlice ("XER",(32:ii),(35:ii))) :: iR in
     let oR =
       (RSlice ("CR",add_VII (reset_vector_start (mult_IVV (4:ii) (reset_vector_start BF))) (32:ii),add_VII
                                                                                                      (reset_vector_start (mult_IVV
                                                                                                                             (4:ii)
                                                                                                                             (reset_vector_start BF)))
                                                                                                      (35:ii))) ::
         (RSlice ("XER",(32:ii),(35:ii))) :: oR in
     return (aR,oR,iR,Nias,ik)
  | Dlmzb (RS,RA,RB,Rc) -> return (aR,oR,iR,Nias,ik)
  | Macchws (RT,RA,RB,OE,Rc) -> return (aR,oR,iR,Nias,ik)
  | Macchwu (RT,RA,RB,OE,Rc) -> return (aR,oR,iR,Nias,ik)
  | Macchwsu (RT,RA,RB,OE,Rc) -> return (aR,oR,iR,Nias,ik)
  | Machhws (RT,RA,RB,OE,Rc) -> return (aR,oR,iR,Nias,ik)
  | Machhwu (RT,RA,RB,OE,Rc) -> return (aR,oR,iR,Nias,ik)
  | Machhwsu (RT,RA,RB,OE,Rc) -> return (aR,oR,iR,Nias,ik)
  | Maclhw (RT,RA,RB,OE,Rc) -> return (aR,oR,iR,Nias,ik)
  | Maclhws (RT,RA,RB,OE,Rc) -> return (aR,oR,iR,Nias,ik)
  | Maclhwu (RT,RA,RB,OE,Rc) -> return (aR,oR,iR,Nias,ik)
  | Maclhwsu (RT,RA,RB,OE,Rc) -> return (aR,oR,iR,Nias,ik)
  | Mulchw (RT,RA,RB,Rc) -> return (aR,oR,iR,Nias,ik)
  | Mulchwu (RT,RA,RB,Rc) -> return (aR,oR,iR,Nias,ik)
  | Mulhhw (RT,RA,RB,Rc) -> return (aR,oR,iR,Nias,ik)
  | Mulhhwu (RT,RA,RB,Rc) -> return (aR,oR,iR,Nias,ik)
  | Mullhw (RT,RA,RB,Rc) -> return (aR,oR,iR,Nias,ik)
  | Mullhwu (RT,RA,RB,Rc) -> return (aR,oR,iR,Nias,ik)
  | Nmacchw (RT,RA,RB,OE,Rc) -> return (aR,oR,iR,Nias,ik)
  | Nmacchws (RT,RA,RB,OE,Rc) -> return (aR,oR,iR,Nias,ik)
  | Nmachhw (RT,RA,RB,OE,Rc) -> return (aR,oR,iR,Nias,ik)
  | Nmachhws (RT,RA,RB,OE,Rc) -> return (aR,oR,iR,Nias,ik)
  | Nmaclhw (RT,RA,RB,OE,Rc) -> return (aR,oR,iR,Nias,ik)
  | Nmaclhws (RT,RA,RB,OE,Rc) -> return (aR,oR,iR,Nias,ik)
  | Icbi (RA,RB) -> return (aR,oR,iR,Nias,ik)
  | Icbt (CT,RA,RB) -> return (aR,oR,iR,Nias,ik)
  | Dcba (RA,RB) -> return (aR,oR,iR,Nias,ik)
  | Dcbt (TH,RA,RB) -> return (aR,oR,iR,Nias,ik)
  | Dcbtst (TH,RA,RB) -> return (aR,oR,iR,Nias,ik)
  | Dcbz (RA,RB) -> return (aR,oR,iR,Nias,ik)
  | Dcbst (RA,RB) -> return (aR,oR,iR,Nias,ik)
  | Dcbf (L,RA,RB) -> return (aR,oR,iR,Nias,ik)
  | Isync ->
     let ik = IK_barrier Barrier_Isync in
     return (aR,oR,iR,Nias,ik)
  | Lbarx (RT,RA,RB,EH) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_reserve in
     return (aR,oR,iR,Nias,ik)
  | Lharx (RT,RA,RB,EH) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_reserve in
     return (aR,oR,iR,Nias,ik)
  | Lwarx (RT,RA,RB,EH) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_reserve in
     return (aR,oR,iR,Nias,ik)
  | Stbcx (RS,RA,RB) ->
     let ik = IK_mem_write Write_conditional in
     return (aR,oR,iR,Nias,ik)
  | Sthcx (RS,RA,RB) ->
     let ik = IK_mem_write Write_conditional in
     return (aR,oR,iR,Nias,ik)
  | Stwcx (RS,RA,RB) ->
     let ik = IK_mem_write Write_conditional in
     return (aR,oR,iR,Nias,ik)
  | Ldarx (RT,RA,RB,EH) ->
     let iR =
       if bitU_to_bool (eq_vec_range (RA, (0:ii)))
       then iR
       else (RFull (access GPRs (unsigned (reset_vector_start RA)))) :: iR in
     let iR = (RFull (access GPRs (unsigned (reset_vector_start RB)))) :: iR in
     let aR = iR in
     let oR = (RFull (access GPRs (unsigned (reset_vector_start RT)))) :: oR in
     let ik = IK_mem_read Read_reserve in
     return (aR,oR,iR,Nias,ik)
  | Stdcx (RS,RA,RB) ->
     let ik = IK_mem_write Write_conditional in
     return (aR,oR,iR,Nias,ik)
  | Sync (L) ->
     let ik =
       match L with
       | Vector [B0;B0] _ _ -> IK_barrier Barrier_Sync
       | Vector [B0;B1] _ _ -> IK_barrier Barrier_LwSync
       end in
     return (aR,oR,iR,Nias,ik)
  | Eieio ->
     let ik = IK_barrier Barrier_Eieio in
     return (aR,oR,iR,Nias,ik)
  | Wait (WC) -> return (aR,oR,iR,Nias,ik)
  end >>= fun (aR, oR, iR, Nias, ik) ->
  return (iR,oR,aR,Nias,Dia,ik)

